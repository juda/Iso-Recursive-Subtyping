Require Import Metalib.Metatheory.
Require Import Program.Equality.
Require Export subtyping.


Lemma strengthening_wf: forall E1 E2 T X m,
    WF (E1 ++ X ~ m ++ E2) T->
    X \notin fv_tt T ->
    WF (E1 ++ E2) T.
Proof with auto.
  intros.
  dependent induction H...
  -
    analyze_binds H...
    simpl.
    apply D.F.singleton_iff...
  -
    simpl in H1.
    constructor...
    apply IHWF1 with (X0:=X) (m0:=m)...
    apply IHWF2 with (X0:=X) (m0:=m)...
  -
    simpl in H1.
    apply WF_rec with (L:=L \u {{X}}).
    intros.
    rewrite_alist (([(X0, bind_sub)] ++ E1) ++ E2).
    apply H0 with (X1:=X) (m0:=m)...
    apply notin_fv_tt_open_aux...
Qed.   

Lemma strengthening_sa: forall E1 E2 A B X m,
    sub (E1 ++ X ~ m ++ E2) A B ->
    X \notin (fv_tt A \u fv_tt B) ->
    wf_env  (E1 ++ E2 ) ->
    sub (E1 ++ E2) A B.
Proof with auto.
  intros.
  dependent induction H...
  -
    constructor...
    analyze_binds H0...
    apply AtomSetImpl.union_2.
    apply D.F.singleton_iff...
  -
    constructor...
    apply strengthening_wf with (X:=X) (m:=m)...
  -
    simpl in H1.
    constructor...
    apply IHsub1 with (X0:=X) (m0:=m)...
    apply IHsub2 with (X0:=X) (m0:=m)...
  -
    simpl in H1.
    apply sa_rec with (L:=L \u {{X}} \u dom (E1 ++ E2)).
    intros.
    rewrite_alist (([(X0, bind_sub)] ++ E1) ++ E2).
    apply H0 with (X1:=X) (m0:=m)...
    apply notin_union.
    split.
    apply notin_fv_tt_open_aux...
    apply notin_fv_tt_open_aux...
    rewrite_alist ([(X0, bind_sub)] ++ E1 ++ E2).
    constructor...
    intros.
    rewrite_alist (([(X0, bind_sub)] ++ E1) ++ E2).
    apply H2 with (X1:=X) (m0:=m)...
    apply notin_union.
    split.
    apply notin_fv_tt_open_aux...
    apply notin_fv_tt_open_aux...
    apply notin_fv_tt_open_aux...
    apply notin_fv_tt_open_aux...
    rewrite_alist ([(X0, bind_sub)] ++ E1 ++ E2).
    constructor...
Qed.

Lemma chooseS_open: forall C X D  A (Y : atom) m,
    X <> Y ->
    type D -> type C ->
    chooseS m X C D (open_tt A Y) = open_tt (chooseS m X C D A) Y.
Proof with auto.
  intros.
  unfold chooseS.
  destruct m...
  rewrite subst_tt_open_tt...
  f_equal...
  rewrite <- subst_tt_fresh ...
  rewrite subst_tt_open_tt...
  f_equal...
  rewrite <- subst_tt_fresh ...
Qed.


Lemma chooseS_open2: forall C X D  A (Y : atom) m,
    X <> Y ->
    type D -> type C ->
    chooseS m X C D (open_tt A (open_tt A Y)) = open_tt (chooseS m X C D A) (open_tt (chooseS m X C D A) Y).
Proof with auto.
  intros.
  unfold chooseS.
  destruct m.
  rewrite subst_tt_open_tt ...
  f_equal...
  rewrite subst_tt_open_tt_var...
  rewrite subst_tt_open_tt ...
  f_equal...
  rewrite subst_tt_open_tt_var...
Qed.




Lemma wf_type: forall E A,
    WF E A -> type A.
Proof with auto.
  intros.
  induction H...
  apply type_mu with (L:=L)...
Qed.

Lemma wf_weakening: forall E1 E2 T E,
    WF (E1 ++ E2) T ->
    WF (E1 ++ E ++ E2) T.
Proof with auto.
  intros.
  generalize dependent E.
  dependent induction H;intros...
  -
    apply WF_rec with (L:=L)...
    intros.
    rewrite_alist (([(X, bind_sub)] ++ E1) ++ E ++ E2).
    apply H0...
Qed.

Lemma subst_tt_wf: forall E A B X,
    WF E A ->
    WF E B ->
    WF E (subst_tt X A B).
Proof with auto.
  intros.
  generalize dependent A.
  induction H0;intros...
  -
    simpl.
    destruct (X0==X)...
  -
    simpl...
  -
    simpl...
    apply WF_rec with (L:=L \u {{X}})...
    intros...
    rewrite subst_tt_open_tt_var...
    apply H0...
    rewrite_alist (nil ++ [(X0, bind_sub)] ++ E).
    apply wf_weakening...
    apply wf_type in H1...
Qed.    

Lemma sub_weakening: forall E E1 E2 A B,
    sub (E1++E2) A B ->
    wf_env (E1 ++ E ++ E2) ->
    sub (E1++E++E2) A B.
Proof with auto.
  intros.
  generalize dependent E.
  dependent induction H;intros...
  -
    constructor...
    apply wf_weakening...
  -
    apply sa_rec with (L:=L \u dom (E1 ++ E ++ E2))...
    intros.
    rewrite_alist (([(X, bind_sub)] ++ E1) ++ E ++ E2).
    apply H0...
    rewrite_alist ([(X, bind_sub)] ++ E1 ++ E ++ E2)...
    intros.
    rewrite_alist (([(X, bind_sub)] ++ E1) ++ E ++ E2)...
    apply H2...
    rewrite_alist ([(X, bind_sub)] ++ E1 ++ E ++ E2)...
Qed.


Lemma sub_eq : forall A B E,
    sub E A B -> sub E B A -> A = B.
Proof with auto.
  induction 1; intros; simpl in *; eauto.
  -
    dependent destruction H1; eauto.
  -
    dependent destruction H1.
    rewrite IHsub1; eauto.
    rewrite IHsub2; eauto.
  -
    dependent destruction H3.
    f_equal.
    pick fresh X.
    apply open_rec_eq with (X:=X) (n:=0)...
    unfold open_tt in *...
    apply H0...
    apply H3...
Qed.

Lemma type_mu_open: forall A X,
    X \notin fv_tt A ->
    type (typ_mu A) ->
    type (open_tt A X).
Proof with auto.
  intros.
  dependent destruction H0.
  pick fresh Y.
  assert (Y \notin L) by auto.
  specialize (H0 _ H1).
  rewrite subst_tt_intro with (X:=Y)...
  apply subst_tt_type...
Qed.  

Lemma sub_generalize_intensive : forall E1 E2 A B,
    sub (E1 ++ E2) A B ->
    forall C D (X:atom) m,
      sub  E2 (open_tt C X) (open_tt D X) ->
      X \notin fv_tt C \u fv_tt D -> 
      sub (E1 ++ E2) (chooseS m X (open_tt C X) (open_tt D X) A) (chooseS m X (open_tt D X) (open_tt C X) B) ->
      sub E2 (typ_mu C) (typ_mu D) ->                  
    sub (E1 ++ E2) (chooseS m X (typ_mu C) (typ_mu D) A) (chooseS m X (typ_mu D) (typ_mu C) B).
Proof with auto.
  intros.
  dependent induction H; simpl in *; eauto.
  -
    destruct m; unfold chooseD; eauto.
  -
    destruct m; simpl in *; subst; eauto; destruct (X == X0); simpl in *; eauto.
    subst.
    assert (sub (nil ++ E1 ++ E2) (open_tt C X0) (open_tt D X0)). 
    apply sub_weakening...
    simpl in *...
    apply sub_eq in H3...
    unfold open_tt in H3.
    apply open_rec_eq in H3...
    subst.
    apply refl_algo...
    apply suba_regular in H4...
    apply soundness_wf...
    rewrite_alist (nil ++ E1 ++ E2).
    apply wf_weakening...
    simpl...
    apply H4...
    rewrite_alist (nil ++ E1 ++ E2).
    apply sub_weakening...
  -
    destruct m; unfold chooseS; simpl in *; eauto.
    constructor...
    apply subst_tt_wf...
    apply suba_regular in H4.
    destruct H4.
    destruct H5.
    rewrite_alist (nil ++ E1 ++ E2).
    apply wf_weakening...
    constructor...
    apply subst_tt_wf...
    apply suba_regular in H4.
    destruct H4.
    destruct H5.
    rewrite_alist (nil ++ E1 ++ E2).
    apply wf_weakening... 
  -
    rewrite chooseS_arrow.
    rewrite chooseS_arrow.
    rewrite chooseS_arrow in H3.
    rewrite chooseS_arrow in H3.
    dependent destruction H3.
    constructor...
    eapply IHsub1 with (m:=flip m) in H1; eauto.
    destruct m; simpl in *; eauto.
    destruct m; simpl in *; eauto.
  -
    rewrite chooseS_mu.
    rewrite chooseS_mu.
    rewrite chooseS_mu in H5.
    rewrite chooseS_mu in H5.
    dependent destruction H5.
    
    assert (type (typ_mu C) /\ type (typ_mu D)).
    {
      apply suba_regular in H7.
      destruct H7.
      destruct H8.
      apply wf_type in H8.
      apply wf_type in H9.
      split...
    }
    destruct H8.
    assert (type (open_tt C X)).
    apply type_mu_open...
    assert (type (open_tt D X)).
    apply type_mu_open...
    
    apply sa_rec with (L := L \u L0 \u fv_tt A1 \u fv_tt A2 \u fv_tt C \u fv_tt D \u {{X}} \u dom E1 \u dom E2).
    +
      intros.      
      rewrite_alist (([(X0, bind_sub)] ++ E1) ++ E2).
      rewrite <- chooseS_open...
      rewrite <- chooseS_open...
      apply H0...
      rewrite chooseS_open...
      rewrite chooseS_open...
      rewrite_alist ([(X0, bind_sub)] ++ E1 ++ E2)...
   +
      intros.      
      rewrite_alist (([(X0, bind_sub)] ++ E1) ++ E2).
      rewrite <- chooseS_open2...
      rewrite <- chooseS_open2...
      apply H2...
      rewrite chooseS_open2...
      rewrite chooseS_open2...
      rewrite_alist ([(X0, bind_sub)] ++ E1 ++ E2)...
Qed. 


Lemma unfolding_lemma_version2 :
  forall E A B,
    sub E (typ_mu A) (typ_mu B) ->
    sub E (open_tt A (typ_mu A)) (open_tt B (typ_mu B)).
Proof with auto.
  intros.
  assert (Ht:=H).
  dependent destruction H.
  pick fresh X.
  assert (X \notin L) by eauto.
  specialize (H0 X H1).
  specialize (H X H1).
  rewrite_alist (nil ++ ([(X, bind_sub)] ++ E)) in H.
  apply sub_generalize_intensive with (C:=A) (X:=X) (D:=B) (m:=Pos) (E1:=empty) (A:=open_tt A X) (B:=open_tt B X) in H...
  simpl in H.
  rewrite <- subst_tt_intro in H...
  rewrite <- subst_tt_intro in H...
  rewrite_alist (nil ++ E).
  apply strengthening_sa with (X:=X) (m:=bind_sub)...
  apply notin_union.
  split.
  apply notin_fv_tt_open_aux...
  apply notin_fv_tt_open_aux...
  apply suba_regular in H.
  destruct H.
  inversion H...
  simpl...
  rewrite <- subst_tt_intro...
  rewrite <- subst_tt_intro...
  rewrite_alist (nil ++ [(X, bind_sub)] ++ E).
  apply sub_weakening...
  apply suba_regular in H.
  destruct H...
Qed.

Lemma sub_generalize_intensive_der : forall E1 E2 A B,
    Sub (E1 ++ E2) A B ->
    forall C D X m,
      Sub E2 C D ->
      forall n,
       Sub (E1 ++ E2) (subst_tt X (UnfoldS n X C) C) (subst_tt X (UnfoldS n X D) D) ->
       Sub (E1 ++ E2) (chooseS m X C D A) (chooseS m X D C B) ->
       Sub (E1 ++ E2) (chooseD n m X C D A) (chooseD n m X D C B).
Proof with auto.
  intros.
  dependent induction H; simpl in *; eauto.
  -
    destruct m; unfold chooseD; eauto.
  -
    destruct m; simpl in *; subst; eauto; destruct (X == X0); simpl in *; eauto;subst.
    assert (Sub (empty ++ E1 ++ E2) C D).
    apply Sub_weakening...
    apply Sub_eq in H4...
    subst...
  -
    apply sub_regular in H2.
    destruct H2.
    destruct H4.
    destruct m; unfold chooseD; simpl in *; eauto.    
    constructor...
    apply subst_tt_wfs...
    constructor...
    apply subst_tt_wfs...
  -
    rewrite chooseD_arrow.
    rewrite chooseD_arrow.
    rewrite chooseS_arrow in H3.
    rewrite chooseS_arrow in H3.
    dependent destruction H3.
    constructor.
    eapply IHSub1 with (m:=flip m) in H2...
    destruct m; simpl in *; eauto.
    destruct m; simpl in *;  eauto.
    apply IHSub2...
  -
    rewrite chooseD_mu.
    rewrite chooseD_mu.
    rewrite chooseS_mu in H3.
    rewrite chooseS_mu in H3.
    dependent destruction H3.
    apply SA_rec with (L := L \u L0 \u fv_tt A1 \u fv_tt A2 \u fv_tt C \u fv_tt D \u {{X}} \u dom E1 \u dom E2).
    intros.
    assert (X0 \notin L) by eauto.
    assert (type C /\ type D) as q.
    {
      apply sub_regular in H1.
      destruct H1.
      destruct H6.
      apply wfs_type in H6.
      apply wfs_type in H7.
      split...
    }
    destruct q.
    rewrite  chooseD_unfold...
    rewrite  chooseD_unfold...
    rewrite_alist (([(X0, bind_sub)] ++ E1) ++ E2).
    apply H0...
    rewrite_alist (nil ++ [(X0, bind_sub)] ++ (E1 ++ E2)).
    apply Sub_weakening...
    specialize (H 0 _ H5).
    apply sub_regular in H.
    apply H...
    rewrite <- chooseS_unfold...
    rewrite <- chooseS_unfold...
    rewrite_alist ([(X0, bind_sub)] ++ E1 ++ E2)...
Qed.


Lemma sub_subst_ver2 : forall E A B,
    Sub E A B -> forall X, 
    Sub E (subst_tt X A A) (subst_tt X B B) -> forall n, 
        Sub E (subst_tt X (UnfoldS n X A) A) (subst_tt X (UnfoldS n X B) B).
Proof with auto.
  intros.
  assert (E = nil ++ E) by eauto.
  induction n...
  rewrite H1 in *. 
  eapply sub_generalize_intensive_der with (X:=X) (E1:=empty) (A:=A) (B:=B) (m:=Pos) (n:=n) in H; simpl in *...
Qed.

