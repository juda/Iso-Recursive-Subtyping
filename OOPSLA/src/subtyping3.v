Require Import Metalib.Metatheory.
Require Import Program.Equality.
Require Export amber_part_2.
Require Export subtyping2.

Lemma subst_tt_wf_v2: forall E1 E2 A B X,
    WF (E1 ++ X ~ bind_sub ++ E2) B ->
    WF (E1 ++ E2) A ->
    WF (E1 ++ E2) (subst_tt X A B).
Proof with auto.
  intros.
  generalize dependent A.
  dependent induction H;intros;simpl...
  -
    destruct (X0==X)...
    constructor...
    analyze_binds H...
  -
    apply WF_rec with (L:=L \u {{X}})...
    intros...
    rewrite subst_tt_open_tt_var...
    rewrite_alist (([(X0, bind_sub)] ++ E1) ++ E2).
    apply H0...
    rewrite_alist (nil ++ [(X0, bind_sub)] ++ (E1 ++ E2)).
    apply wf_weakening...
    apply wf_type in H1...
Qed.

  
Lemma sub_amber2_refl: forall E A,
    wf_env E ->
    WF E A ->
    sub_amber2 E A A.
Proof with auto.
  intros.
  induction H0...
  apply sam2_refl...
  apply WF_rec with (L:=L)...
Qed.


Lemma sub_amber2_weakening: forall E1 E2 A B E,
    sub_amber2 (E1 ++ E2) A B ->
    wf_env (E1 ++ E ++ E2) ->
    sub_amber2 (E1 ++ E ++ E2) A B.
Proof with auto.
  intros.
  generalize dependent E.
  dependent induction H;intros...
  -
    constructor...
    apply wf_weakening...
  -
    apply sam2_rec with (L:=L \u dom (E1 ++ E ++ E2)).
    intros.
    rewrite_alist (([(X, bind_sub)] ++ E1) ++ E ++ E2)...
    apply H0...
    rewrite_alist ([(X, bind_sub)] ++ E1 ++ E ++ E2)...
    intros...
  -
    apply sub_amber2_refl...
    apply wf_weakening...
Qed.    

    
Lemma sub_amber2_unfolding: forall A B,
    typePairR A B ->
    forall C D X m n E,
    sub_amber2 E A B ->
    posvar m X A B ->
    sub_amber2 E C D ->
    posvar n X C D ->
    sub_amber2 E (chooseS m X C D A) (chooseS m X D C B).
Proof with auto.
  intros A B H.
  dependent induction H;intros...
  -
    destruct m...
  -
    apply suba2_regular in H2.
    destruct H2.
    destruct H4.
    apply suba2_regular in H0.
    destruct H0.
    destruct H6.
    destruct m;simpl;constructor...
    apply subst_tt_wf...
    apply subst_tt_wf...
  -
    dependent destruction H0.
    destruct m...
  -
    destruct m;simpl;destruct (X==X0)...
    inversion H0.
    destruct H6...
  -
    dependent destruction H1.
    dependent destruction H2.
    rewrite chooseS_arrow.
    rewrite chooseS_arrow.
    constructor...
    destruct m;simpl in *...
    specialize (IHtypePairR1 C D X _ _ E H1_ H2_ H3 H4).
    simpl...
    specialize (IHtypePairR1 C D X _ _ E H1_ H2_ H3 H4).
    simpl...
    apply IHtypePairR2 with (n:=n)...
  -
    dependent destruction H1.
    +
      dependent destruction H3.
      *
        assert (Ht:=H6).
        apply posvar_regular in Ht.
        destruct Ht.
        rewrite chooseS_mu.
        rewrite chooseS_mu.
        apply sam2_rec with (L:=L \u L1 \u L0 \u {{X}} \u fv_tt C \u fv_tt D \u dom E)...
        --
          intros.
          rewrite <- chooseS_open...
          rewrite <- chooseS_open...
          apply H0 with (n:=n)...
          rewrite_alist (nil ++ [(X0, bind_sub)] ++ E).
          apply sub_amber2_weakening...
          simpl...
          constructor...
          apply suba2_regular in H5.
          apply H5.
        --
          intros.
          rewrite <- chooseS_open...
          rewrite <- chooseS_open...
          assert (X0 \notin L0 ) by auto.
          specialize (H2 _ H10).
          assert (Ht:=H2).
          apply posvar_typePairR in Ht.
          destruct m;simpl.
          apply posvar_calc_sign with (X:=X0) (Y:=X) (C:=D) (D:=C) (m1:=Pos) (m2:=Neg) (m4:=n) in Ht...
          apply Ht.
          apply pos_rename_3 with (X:=X) (m:=n)...
          apply posvar_comm...
          apply posvar_comm...
          apply posvar_calc_sign with (X:=X0) (Y:=X) (C:=C) (D:=D) (m1:=Pos) (m2:=Pos) (m4:=n) in Ht...
          apply Ht.
          apply pos_rename_3 with (X:=X) (m:=n)...
      *
        assert (Ht:=H6).
        apply posvar_regular in Ht.
        destruct Ht.
        rewrite chooseS_mu.
        rewrite chooseS_mu.
        apply sam2_rec with (L:=L \u L1 \u L0 \u {{X}} \u fv_tt C \u fv_tt D \u dom E)...
        --
          intros.
          rewrite <- chooseS_open...
          rewrite <- chooseS_open...
          apply H0 with (n:=n)...
          apply posvar_self_notin...
          apply notin_fv_tt_open_aux...  
          rewrite_alist (nil ++ [(X0, bind_sub)] ++ E).
          apply sub_amber2_weakening...
          simpl...
          constructor...
          apply suba2_regular in H5.
          apply H5.
        --
          intros.
          rewrite <- chooseS_open...
          rewrite <- chooseS_open...
          destruct m;simpl.
          rewrite <- subst_tt_fresh...
          rewrite <- subst_tt_fresh...
          apply notin_fv_tt_open_aux...  
          apply notin_fv_tt_open_aux...
          rewrite <- subst_tt_fresh...
          rewrite <- subst_tt_fresh...
          apply notin_fv_tt_open_aux...  
          apply notin_fv_tt_open_aux...
    +
      dependent destruction H3.
      *
        assert (Ht:=H6).
        apply posvar_regular in Ht.
        destruct Ht.
        rewrite chooseS_mu.
        rewrite chooseS_mu.
        dependent destruction H2.
        apply sam2_rec with (L:=L \u L1  \u L0 \u {{X}} \u fv_tt C \u fv_tt D \u dom E)...
        --
          intros.
          rewrite <- chooseS_open...
          rewrite <- chooseS_open...
          apply H0 with (n:=n)...
          apply sub_amber2_refl...
          rewrite_alist (nil ++ [(X0, bind_sub)] ++ E).
          apply sub_amber2_weakening...
          simpl...
          constructor...
        --
          intros.
          rewrite <- chooseS_open...
          rewrite <- chooseS_open...
          assert (X0 \notin L1 \u {{X}} ) by auto.
          specialize (H4 _ H10).
          assert (Ht:=H4).
          apply posvar_typePairR in Ht.
          destruct m;simpl.          
          apply posvar_calc_sign with (X:=X0) (Y:=X) (C:=D) (D:=C) (m1:=Pos) (m2:=Neg) (m4:=n) in Ht...
          apply Ht.
          apply pos_rename_3 with (X:=X) (m:=n)...
          apply posvar_comm...
          apply posvar_comm...
          apply posvar_calc_sign with (X:=X0) (Y:=X) (C:=C) (D:=D) (m1:=Pos) (m2:=Pos) (m4:=n) in Ht...
          apply Ht.
          apply pos_rename_3 with (X:=X) (m:=n)...
      *
        destruct m;simpl.
        rewrite <- subst_tt_fresh...
        rewrite <- subst_tt_fresh...
        rewrite <- subst_tt_fresh...
        rewrite <- subst_tt_fresh...
Qed.

Lemma sub_amber2_strengthing: forall E1 E2 A B (X : atom),
    sub_amber2 (E1 ++ X ~ bind_sub ++ E2) A B ->
    wf_env (E1 ++ E2) ->
    X \notin fv_tt A \u fv_tt B ->
    sub_amber2 (E1 ++ E2) A B.
Proof with auto.
  intros.
  dependent induction H...
  -
    constructor...
    apply strengthening_wf in H...
  -
    constructor...
    analyze_binds H.
    apply AtomSetImpl.union_2.
    apply D.F.singleton_iff...
  -
    simpl in H2.
    constructor...
    apply IHsub_amber2_1 with (X0:=X)...
    apply IHsub_amber2_2 with (X0:=X)...
  -
    apply sam2_rec with (L:=L \u {{X}} \u dom (E1++E2)).
    intros.
    rewrite_alist (([(X0, bind_sub)] ++ E1) ++ E2)...
    apply H0 with (X1:=X)...
    rewrite_alist ([(X0, bind_sub)] ++ E1 ++ E2)...
    apply notin_union.
    split.
    apply notin_fv_tt_open_aux...  
    apply notin_fv_tt_open_aux...  
    intros...
  -
    apply sub_amber2_refl...
    apply strengthening_wf in H0...
Qed.
    
    
Lemma unfolding_for_pos: forall E A B,
    sub_amber2 E (typ_mu A) (typ_mu B) ->
    sub_amber2 E (open_tt A (typ_mu A)) (open_tt B (typ_mu B)).
Proof with auto.
  intros.
  assert (Ht:=H).
  dependent destruction H.
  -
    pick fresh Y.
    rewrite subst_tt_intro with (X:=Y)...
    remember (subst_tt Y (typ_mu A) (open_tt A Y)).
    rewrite subst_tt_intro with (X:=Y)...
    subst.
    rewrite_alist (nil ++ E).
    assert (Y \notin L) as qt by auto.
    specialize (H Y qt).
    apply sub_amber2_unfolding with (C:=typ_mu A) (D:=typ_mu B) (m:=Pos) (X:=Y) (n:=Pos) in H...
    simpl in H...
    rewrite_alist (nil ++ Y ~ bind_sub ++ E) in H.
    apply sub_amber2_strengthing in H...
    apply suba2_regular in Ht.
    apply Ht.
    apply notin_union.
    split.
    rewrite <- subst_tt_intro...
    apply notin_fv_tt_open_aux...
    rewrite <- subst_tt_intro...
    apply notin_fv_tt_open_aux...
    specialize (H0 _ qt).
    apply posvar_typePairR in H0...
    rewrite_alist (nil ++ Y ~ bind_sub ++ E).
    apply sub_amber2_weakening...
    apply suba2_regular in Ht.
    simpl.
    constructor...
    apply Ht.
    apply pos_rec with (L:=L).
    intros.
    assert (Y0 \notin L) as qs by auto.
    specialize (H0 _ qs).
    apply pos_rename_3 with (X:=Y0) (m:=Pos)...
    apply notin_union.
    split...
    apply notin_union.
    split...
    apply notin_fv_tt_open_aux...
    apply notin_fv_tt_open_aux...
    intros.
    apply H0...
  -
    apply sub_amber2_refl...
    assert (Hh:=H0).
    dependent destruction H0.
    pick fresh Y.
    rewrite subst_tt_intro with (X:=Y)...
    rewrite_alist (nil ++ E).
    apply subst_tt_wf_v2...
    apply H0...
Qed.

Lemma sub_amber2_trans_aux: forall E B,
    WF E B ->
    forall A C m X,
      sub_amber2 E A B ->
      sub_amber2 E B C ->
      posvar m X A B ->
      posvar m X B C ->
      sub_amber2 E A C /\ posvar m X A C.
Proof with auto.
  intros E B Hb.
  induction Hb;intros...
  -
    dependent destruction H...
    dependent destruction H1...
  -
    dependent destruction H...
  -
    dependent destruction H0...
  -
    dependent destruction H...
    dependent destruction H1...
    +
      apply suba2_regular in H.
      apply suba2_regular in H0.
      destruct H.
      destruct H5.
      destruct H0.
      destruct H7.
      split;constructor...
      apply wf_type in H6.
      apply wf_type in H7...
    +
      dependent destruction H2...
      dependent destruction H3...
      split...
      constructor...
      apply IHHb1 with (m:=flip m) (X:=X)...
      apply IHHb2 with (m:= m) (X:=X)...
      constructor...
      apply IHHb1 with (m:=flip m) (X:=X)...
      apply IHHb2 with (m:= m) (X:=X)...      
  -
    dependent destruction H1...
    dependent destruction H3...
    +
      split;constructor...
      apply WF_rec with (L:=L0)...
      intros...
      specialize (H1 _ H7).
      apply suba2_regular in H1.
      apply H1.
      apply posvar_regular in H5.
      apply H5.
    +
      split.
      apply sam2_rec with (L:=L \u L0 \u L1).
      intros.
      eapply H0...
      intros.
      eapply H0...
      dependent destruction H5...
      dependent destruction H7.
      *
        apply pos_rec with (L:=L \u L0 \u L1 \u L2 \u L3).
        intros...
        eapply H0...
        intros...
        eapply H0...
      *
        apply pos_rec with (L:=L \u L0 \u L1 \u L2 \u L3).
        intros...
        intros...
    +
      split...
      apply sam2_rec with (L:=L0)...
Qed.

Lemma sub_amber2_trans: forall E B,
    WF E B ->
    forall A C ,
      sub_amber2 E A B ->
      sub_amber2 E B C ->
      sub_amber2 E A C.
Proof with auto.
  intros E B Hb.
  induction Hb;intros...
  -
    dependent destruction H...
    dependent destruction H1...
  -
    dependent destruction H...
  -
    dependent destruction H0...
  -
    dependent destruction H...
    dependent destruction H1...
    constructor...
    apply suba2_regular in H.
    apply suba2_regular in H0.
    constructor...
    apply H.
    apply H0.
  -
    dependent destruction H1...
    dependent destruction H3...
    +
      constructor...
      apply WF_rec with (L:=L0).
      intros...
      specialize (H1 _ H5).
      apply suba2_regular in H1.
      apply H1.
    +
      apply sam2_rec with (L:=L \u L0 \u L1).
      intros...
      intros.
      eapply sub_amber2_trans_aux with (B:=open_tt A X)...
    +
      apply sam2_rec with (L:=L \u L0 ).
      intros...
      intros...
Qed.
