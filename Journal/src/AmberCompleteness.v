Require Import Metalib.Metatheory.
Require Import Program.Equality.
Require Export AmberSoundness.
Require Export PositiveSubtyping.


Definition env_mode := list ( Mode).


Inductive monotone: env -> typ -> typ -> env_mode -> Prop :=
| M_base: forall A B,
    monotone nil A B nil
| M_neg: forall A B E  EM  X ,
    monotone E A B EM ->
    posvar Neg X A B ->
    monotone (X~bind_sub ++ E) A B  ( Neg::EM)
| M_pos: forall A B E  EM  X ,
    monotone E A B  EM ->
    posvar Pos X A B ->
    monotone (X~bind_sub ++ E) A B  ( Pos::EM)
.

Fixpoint domL (E : env_amber) : atoms :=
  match E with
  | nil => {}
  | (X,Y)::E' => add X (domL E')
  end.

Fixpoint domR (E : env_amber) : atoms :=
  match E with
  | nil => {}
  | (X,Y)::E' => add Y (domR E')
  end.

Fixpoint domS (E : list atom) : atoms :=
  match E with
  | nil => {}
  | Y::E' => add Y (domS E')
  end.

Inductive env_copy:  env ->  list atom -> atoms -> Prop :=
| EC_base: forall A,
    env_copy  nil  nil A 
| EC_cons1: forall  X EX Y EY m Z A,
    env_copy  EX  EY A ->
    X \notin dom EX ->
    X \in domS EY ->
    Y \notin domS EY \u {{X}} \u dom EX \u A ->
    Z \notin domS EY \u {{Y}} \u {{X}} \u dom EX \u A ->
    env_copy (X~m ++ EX)  (Z :: Y :: EY) A
| EC_cons2: forall  X EX Y EY m A,
    env_copy  EX  EY A ->
    X \notin dom EX \u domS EY->
    Y \notin domS EY \u {{X}} \u dom EX \u A ->
    env_copy (X~m ++ EX)  (X :: Y :: EY) A.

Definition minus A B := forall X, X \in A -> X \notin B.

Inductive env_conv:  env -> env_amber -> Prop :=
| EV_base: 
    env_conv  nil  nil
| EV_cons: forall  X EX Y EY m ,
    env_conv EX EY ->
    env_conv (X~m ++ EX) ((X,Y)::EY).

Inductive distinct:  list atom -> Prop :=
| DT_base: 
    distinct nil  
| DT_cons: forall  X E ,
    distinct E ->
    X \notin domS E ->
    distinct (X::E).


Hint Constructors monotone env_copy env_conv distinct : core.


Ltac gather_atoms ::=
  let A := gather_atoms_with (fun x : atoms => x) in
  let B := gather_atoms_with (fun x : atom => singleton x) in
  let E := gather_atoms_with (fun x : typ => fv_tt x) in
  let C := gather_atoms_with (fun x : list (var * typ) => dom x) in
  let D := gather_atoms_with (fun x : exp => fv_exp x) in
  let F := gather_atoms_with (fun x : env => dom x) in
  let G := gather_atoms_with (fun x : env_amber => domA x) in
  let H := gather_atoms_with (fun x : env_amber => domL x) in
  let I := gather_atoms_with (fun x : env_amber => domR x) in
  let J := gather_atoms_with (fun x : list atom => domS x) in
  constr:(A `union` B `union`  E \u C \u D \u F \u G \u H \u I \u J).



Lemma env_copy_length: forall E  Ea A,
    env_copy E Ea A ->
    2 * length E =  (length Ea).
Proof with auto.
  intros.
  induction H...
  -
    rewrite app_length.
    rewrite Nat.mul_add_distr_l.
    simpl.
    f_equal.
    f_equal...
  -
    rewrite app_length.
    rewrite Nat.mul_add_distr_l.
    simpl.
    f_equal.
    f_equal...
Qed.

Lemma wf_env_decompose: forall a b E,
    wf_env ((a~b)++E) -> wf_env E /\ a \notin dom E.
Proof with auto.
  intros.
  dependent induction H...
Qed.  
  
Lemma existence_env_copy: forall E ,
    wf_env E ->  forall A,
    exists G, env_copy E G A /\ dom E [<=] domS G /\ distinct G.
Proof with auto.
  intros.
  induction E...
  -
    exists nil...
    repeat split...
    simpl...
    apply Subset_refl.
  -
    destruct a.
    apply wf_env_decompose in H.
    destruct H.
    destruct IHE...
    destruct_hypos.
    assert (a \notin domS x \/ a \in domS x).
    apply in_dec.
    destruct H4.
    +
      pick fresh Y.
      exists (a::Y::x)...
      repeat split...
      apply EC_cons2...
      simpl.
      apply AtomSetProperties.subset_add_3...
      apply KeySetProperties.subset_add_2...
      apply KeySetProperties.subset_add_2...
    +
      pick fresh Y.
      pick fresh Z.
      exists (Z::Y::x)...
      repeat split...
      apply EC_cons1...
      simpl.
      apply AtomSetProperties.subset_add_3...
      apply KeySetProperties.subset_add_2...
      apply KeySetProperties.subset_add_2...
Qed.

Fixpoint filter_env (E:env) (G:list atom) : list atom :=
  match E with
  | nil => G
  | (X,_)::E' => filter_env E' (List.remove eq_dec X G)
  end.

Fixpoint domE (E:env) : list atom :=
  match E with
  | nil => nil
  | (X,m)::E' => X::(domE E')
  end.


Definition disjoint (E:atoms) (G:atoms) :=
  forall X, (X \in E -> X \notin G) /\ (X \in G -> X \notin E).

Lemma dom_split: forall X A B,
    add X A [<=] B ->
    X \in B /\ A [<=] B.
Proof with auto.
  intros.
  unfold "[<=]" in *.
  split...
Qed.


Lemma notin_remove : forall a T,
    a \notin domS T ->
    List.remove eq_dec a T = T.
Proof with auto.
  intros.
  induction T...
  simpl in *.
  assert (Ht:=H).
  apply notin_add_1 in H.
  apply notin_add_2 in Ht...
  apply IHT in Ht.
  destruct (a==a0)...
  destruct H...
  rewrite Ht...
Qed.

Lemma notin_filter_env: forall E T a,
    a \notin dom E ->
    filter_env E (a :: T) = a :: (filter_env E T).
Proof with auto.
  intros E.
  induction E;intros...
  destruct a.
  simpl in *...
  assert (Ht:=H).
  apply notin_add_1 in H.
  apply notin_add_2 in Ht.
  destruct (a==a0)...
  destruct H...
Qed.

Lemma remove_remove_comm: forall l x y,
  List.remove eq_dec x (List.remove eq_dec y l) = List.remove eq_dec y (List.remove eq_dec x l).
Proof with auto.
  intros l.
  induction l;intros...
  simpl.
  destruct (y==a);destruct (x==a)...
  simpl.
  destruct (y==a)...
  destruct n0...
  simpl.
  destruct (x==a)...
  destruct n0...
  simpl.
  destruct (x==a);destruct (y==a)...
  destruct n0...
  destruct n...
  f_equal...
Qed.
  
Lemma notin_remove_dec: forall E T a,
    a \notin dom E ->
    filter_env E (List.remove eq_dec a T) = List.remove eq_dec a (filter_env E T).
Proof with auto.
  intros E.
  induction E;intros...
  destruct a.
  simpl in *...
  rewrite remove_remove_comm...
Qed.

Lemma length_S_remove :forall E a,
    a \in domS E -> distinct E ->
          S (length (List.remove eq_dec a E)) = length E.
Proof with auto.
  intros E.
  induction E;intros...
  simpl in *.
  apply KeySetFacts.empty_iff in H.
  destruct H.
  simpl in *.
  dependent destruction H0.
  apply F.add_iff in H.
  destruct H...
  +
    destruct (a0==a)...
    subst.
    f_equal...
    rewrite notin_remove...
    destruct n...
  +
    destruct (a0==a)...
    assert (False).
    subst.
    apply H1...
    destruct H2.
    f_equal...
    simpl...
Qed.    


Lemma notin_filter_env1: forall T X a,
    X <> a ->
    X \in domS T ->
    X `in` domS (List.remove eq_dec a T).
Proof with auto.
  intros T.
  induction T;intros...
  simpl in *.
  destruct (a0==a)...
  apply IHT...
  subst.
  apply KeySetProperties.FM.add_iff in H0...
  destruct H0...
  destruct H0...
  destruct H...
  apply KeySetProperties.FM.add_iff in H0...
  destruct H0...
  subst...
  simpl...
  specialize (IHT _ _ H H0)...
  simpl...
Qed.

Lemma notin_filter_env2: forall E T a,
    wf_env E ->
    a `notin` dom E -> a `in` domS T -> a `in` domS (filter_env E T).
Proof with auto.
  intros E.
  induction E;intros...
  destruct a.
  simpl in *.
  apply wf_env_decompose in H.
  destruct_hypos.
  rewrite notin_remove_dec...
  apply notin_filter_env1...
Qed.

Lemma notin_remove_dom: forall T a b,
    a \notin domS T ->
    a `notin` domS (List.remove eq_dec b T).
Proof with auto.
  intros T.
  induction T;intros...
  simpl in *.
  destruct (b==a)...
Qed.

Lemma notin_remove_dom_2: forall T a ,

    a `notin` domS (List.remove eq_dec a T).
Proof with auto.
  intros T.
  induction T;intros...
  simpl in *.
  destruct (a0==a)...
Qed.



Lemma distinct_remove: forall T a,
    distinct T ->
    distinct (List.remove eq_dec a T).
Proof with auto.
  intros.
  induction T...
  simpl...
  dependent destruction H...
  destruct (a==a0)...  
  constructor...
  apply notin_remove_dom...
Qed.

Lemma dom_add_subset: forall a E T,
    a \notin E \u T ->
    add a E [<=] add a T ->
    E [<=] T.
Proof with auto.
  intros.
  unfold "[<=]" in *.
  intros.
  specialize (H0 a0).
  assert (a0 \in add a E).
  apply AtomSetImpl.add_2...
  apply H0 in H2.
  apply KeySetProperties.FM.add_iff in H2...
  destruct H2...
  subst...
  assert (False).
  apply H...
  destruct H2.
Qed.

Lemma filter_nil: forall E,
    filter_env E nil = nil.
Proof with auto.
  intros.
  induction E...
  unfold filter_env...
  destruct a.
  assert (List.remove eq_dec a nil = nil)...
Qed.



Lemma filter_env_dist_S: forall  E a T2,
    filter_env E (a :: T2) = filter_env E [a] ++ filter_env E T2.
Proof with auto.
  intros E.
  induction E;intros...
  simpl...
  destruct a.
  destruct (a==a0)...
  -
    subst...
    rewrite filter_nil...
  -
    apply IHE...
Qed.
    
Lemma filter_env_dist: forall  T1 E T2,
    filter_env E (T1 ++ T2) = filter_env E T1 ++ filter_env E T2.
Proof with auto.
  intros T1.
  induction T1;intros...
  -
    simpl...
    rewrite filter_nil...
  -
    simpl...
    rewrite filter_env_dist_S.
    rewrite filter_env_dist_S.
    rewrite app_assoc...
    f_equal...
Qed.

    
Lemma dom_dec: forall a E,
    wf_env E ->
    a \in dom E \/ a \notin dom E.
Proof with auto.
  intros.
  induction E...
  destruct a0;simpl...
  apply wf_env_decompose in H.
  destruct_hypos.
  apply IHE in H.
  destruct H...
  destruct (a==a0).
  left...
  right...
Qed.  
  
Lemma dom_in_distinct: forall a E,
    a \in dom E ->
          filter_env E [a] = nil.
Proof with auto.
  intros.
  induction E...
  apply KeySetFacts.empty_iff in H.
  destruct H.
  simpl...
  destruct a0.
  destruct (a0==a)...
  apply filter_nil...
  apply IHE...
  simpl in *.
  apply KeySetProperties.FM.add_iff in H...
  destruct H...
  destruct n...
Qed.

Lemma dom_notin_distinct: forall a E,
    a \notin dom E ->
          filter_env E [a] = [a].
Proof with auto.
  intros.
  induction E...
  simpl in *.
  destruct a0.
  destruct (a0==a)...
  apply notin_add_1 in H.
  destruct H...  
Qed.

Lemma notin_filter_dom: forall T a E,
    a \notin domS T ->
    wf_env E ->
    a `notin` domS (filter_env E T).
Proof with auto.
  intros T.
  induction T;intros...
  rewrite filter_nil...
  rewrite filter_env_dist_S...
  simpl in *.
  assert (Ht:=H0).
  apply dom_dec with (a:=a) in Ht.
  destruct Ht.
  -
    rewrite dom_in_distinct...
    simpl...
  -
    rewrite dom_notin_distinct...
Qed.

Lemma notin_filter_dom_2: forall E a T,
    a \in dom E ->
    wf_env E ->
    a `notin` domS (filter_env E T).
Proof with auto.
  intros E.
  induction E;intros...
  simpl in *.
  apply KeySetFacts.empty_iff in H.
  destruct H.
  destruct a.
  simpl in *.
  apply KeySetProperties.FM.add_iff in H...
  destruct H...
  -
    subst.
    apply wf_env_decompose in H0.
    destruct H0.
    rewrite notin_remove_dec...
    apply notin_remove_dom_2...
  -
    apply wf_env_decompose in H0.
    destruct H0.
    rewrite notin_remove_dec...
    apply notin_remove_dom...
Qed.  
    
Lemma dom_split_2: forall E T a,
    E [<=] add a T ->
    a \notin E ->
    E [<=] T.
Proof with auto.
  intros.
  unfold "[<=]" in *.
  intros.
  assert (Ht:=H1).
  apply H in Ht.
  apply KeySetProperties.FM.add_iff in Ht...
  destruct Ht...  
  subst...
  assert (False).
  apply H0...
  destruct H2.
Qed.  
  
Lemma distinct_filter_env: forall T E,
    wf_env E ->
    distinct T ->
    dom E [<=] domS T ->
    distinct (filter_env E T).
Proof with auto.
  intros T.
  induction T;intros...
  -
    induction E...
    destruct a...
    simpl in *...
    unfold "[<=]" in H1.
    specialize (H1 a).
    assert (a `in` add a (dom E)) by auto.
    apply H1 in H2.
    apply F.empty_iff in H2...
    destruct H2.
  -
    induction E...
    simpl...
    destruct a0...
    destruct (a0==a)...
    +
      subst...
      apply wf_env_decompose in H...
      destruct_hypos...
      rewrite notin_remove_dec...
      apply distinct_remove...
      simpl in *.
      dependent destruction H0.
      apply IHT...
      apply dom_add_subset with (a:=a)...
    +
      apply wf_env_decompose in H...
      destruct_hypos...
      rewrite filter_env_dist_S...
      assert (Ht:=H).
      apply dom_dec with (a:=a) in Ht.
      destruct Ht.
      *
        rewrite dom_in_distinct...
        simpl in *...
        rewrite notin_remove_dec...
        apply distinct_remove...
        apply IHE in H...
        rewrite filter_env_dist_S in H...
        rewrite dom_in_distinct in H...
        apply dom_split in H1...
        destruct_hypos...
      *
        rewrite dom_notin_distinct...
        simpl in *...
        rewrite notin_remove_dec...
        constructor...
        apply distinct_remove...
        apply IHT...
        dependent destruction H0...
        apply dom_split in H1...
        destruct H1.
        apply dom_split_2 in H4...
        dependent destruction H0.
        apply notin_remove_dom...
        apply notin_filter_dom...
Qed.        
        
    
Lemma length_filter_env: forall E T ,
    distinct T ->
    wf_env E ->
    dom E [<=] domS T ->
    length E + length (filter_env E T) = length T.
Proof with auto.
  intros.
  generalize dependent T.
  induction E;intros...
  destruct a.
  simpl in *.
  apply wf_env_decompose in H0.
  apply dom_split in H1.
  destruct_hypos.
  rewrite <- Nat.add_succ_r.
  assert (S (length (filter_env E (List.remove eq_dec a T))) = length (filter_env E T)).
  {
    rewrite notin_remove_dec...
    rewrite length_S_remove...
    apply notin_filter_env2...
    apply distinct_filter_env...
  }
  rewrite H4.
  apply IHE...
Qed.  

Lemma domS_split:forall E1 E2 X,
    X \in domS (E1++E2) -> X \in domS E1 \/ X \in domS E2.
Proof with auto.
  intros E1.
  induction E1;intros...
  simpl in H.
  apply KeySetProperties.FM.add_iff in H.
  destruct H...
  left...
  subst...
  simpl...
  apply IHE1 in H...
  destruct H...
  left...
  simpl...
Qed.  

Lemma notin_filter_dom_3: forall T E X,
    X `in` domS (filter_env E T) ->
         wf_env E ->
         X \notin dom E .
Proof with auto.
  intros T.
  induction T;intros...
  -
    rewrite filter_nil in H.
    simpl in *.
    apply KeySetFacts.empty_iff in H.
    destruct H.
  -
    rewrite filter_env_dist_S in H.
    simpl in *.
    apply domS_split in H.
    destruct H...
    apply dom_dec with (a:=a) in H0.
    destruct H0.
    +
      rewrite dom_in_distinct in H...
      simpl in *.
      apply KeySetFacts.empty_iff in H.
      destruct H.
    +
      rewrite dom_notin_distinct in H...
      simpl in *.
      apply KeySetProperties.FM.add_iff in H.
      destruct H...
      subst...
      apply KeySetFacts.empty_iff in H.
      destruct H.
Qed.

Lemma notin_filter_domS: forall EX EY X Y ,
    X `notin` domS (filter_env EX EY) ->
    X `notin` domS (filter_env EX (List.remove eq_dec Y EY)).
Proof with auto.
  intros EX.
  induction EX;intros...
  simpl in *...
  apply notin_remove_dom...
  destruct a.
  simpl in *...
  rewrite remove_remove_comm...
Qed.  

Lemma minus_filter: forall E A  T,
  env_copy E T A ->
  minus A (domS (filter_env E T)).
Proof with auto.
  intros.
  unfold minus.
  intros.
  dependent induction H...
  -
    assert (Ht:=H4).
    apply IHenv_copy with (X:=X0) in Ht...
    rewrite notin_filter_env...
    rewrite notin_filter_env...
    simpl.
    apply notin_add...
    apply in_notin with (Y:=Z) in H4...
    apply notin_add...
    apply in_notin with (Y:=Y) in H4...
    apply notin_filter_domS...
  -
    assert (Ht:=H2).
    apply IHenv_copy with (X:=X0) in Ht...
    rewrite filter_env_dist_S...
    rewrite dom_in_distinct...
    rewrite app_nil_l...
    rewrite notin_filter_env...
    simpl...
    apply notin_add...
    apply in_notin with (Y:=Y) in H2...
    apply notin_filter_domS...
    simpl...
Qed.    

Lemma existence_env_duplicate: forall E A,
    wf_env E ->
    exists G, length E = length G /\ distinct G /\ disjoint (dom E) (domS G) /\ minus A (domS G).
Proof with auto.
  intros.
  assert (Ht:=H).
  apply existence_env_copy with (A:=A) in H .
  destruct_hypos.
  exists (filter_env E x).
  split.
  -
    assert (2 * length E = length x).
    apply env_copy_length with (A:=A)...
    simpl in H2.
    rewrite <- length_filter_env with (E:=E) in H2...
    apply Nat.add_cancel_l in H2...
    rewrite <- H2...
  -
    split.
    +
      apply distinct_filter_env...
    +
      unfold disjoint.
      intros.
      split.
      split;intros.
      *
        apply notin_filter_dom_2...
      *
        apply notin_filter_dom_3 with (T:=x)...
      *
        apply minus_filter...        
Qed.


Lemma disjoint_subset: forall E T a b,
    disjoint (add a E) (add b T) ->
    disjoint E T.
Proof with auto.
  intros.
  unfold disjoint in *.
  intros.
  specialize (H X).
  destruct_hypos.
  split.
  -
    intros.
    assert (X \in add a E) by auto.
    apply H in H2...
  -
    intros.
    assert (X \in add b T) by auto.
    apply H0 in H2...
Qed.

Lemma disjoint_subset_1: forall E T a b,
    disjoint (add a E) (add b T) ->
    a \notin  T.
Proof with auto.
  intros.
  unfold disjoint in *.
  specialize (H a).
  destruct_hypos.
  assert (a \in add a E) by auto.
  apply H in H1...
Qed.

Lemma disjoint_subset_2: forall E T a b,
    disjoint (add a E) (add b T) ->
    a <>  b.
Proof with auto.
  intros.
  unfold disjoint in *.
  specialize (H a).
  destruct_hypos.
  assert (a \in add a E) by auto.
  apply H in H1...
Qed.

Lemma disjoint_subset_3: forall E T a b,
    disjoint (add a E) (add b T) ->
    b \notin  E.
Proof with auto.
  intros.
  unfold disjoint in *.
  specialize (H b).
  destruct_hypos.
  assert (b \in add b T) by auto.
  apply H0 in H1...
Qed.

Lemma combine_dom_dist: forall k E T a,
    length E <= k ->
    length E = length T ->
    a \notin domS E \u domS T ->
    a `notin` domA (combine E T).
Proof with auto.
  intros k.
  induction k;intros...
  -
    induction E;induction T;simpl in *...
    inversion H.
  -
    destruct E;destruct T;simpl in *...
    apply notin_union.
    split...
    apply notin_union.
    split...
    apply IHk...
    apply le_S_n in H...
Qed.    

Lemma length_domE: forall E,
    length E = length (domE E).
Proof with auto.
  intros.
  induction E...
  destruct a...
  simpl...
Qed.

Lemma notin_domS_E: forall E X,
    X \notin dom E ->
    X \notin domS (domE E).
Proof with auto.
  intros.
  induction E...
  destruct a.
  simpl in *...
Qed.  

Lemma minus_add: forall A x B,
    minus A (add x B) ->
    minus A B.
Proof with auto.
  intros.
  unfold minus in *.
  intros...
  apply H in H0...
Qed.

Lemma combind_domR: forall B A ,
    length A = length B ->
    domR (List.combine A B) = domS B.
Proof with auto.
  intros B.
  induction B;intros...
  destruct A...
  destruct A...
  inversion H...
  simpl...
  f_equal...
Qed.  

Lemma env_copy_wfe_amber: forall E A,
    wf_env E ->
    exists G, env_conv E G /\ wfe_amber G /\ minus A (domR G).
Proof with auto.
  intros.
  assert (H1:=H).
  apply existence_env_duplicate with (A:=A) in H1.
  destruct_hypos.
  exists (List.combine (domE E) x).
  split.
  -
    dependent induction E.
    dependent destruction x...
    dependent destruction x...
    +
      simpl in *.
      inversion H0.
    +
      destruct a.
      simpl in *.
      constructor...
      apply wf_env_decompose in H.
      destruct_hypos.
      apply IHE with (A:=A)...
      dependent destruction H1...
      apply disjoint_subset in H2...
      apply minus_add with (x:=a0)...  
  -
    split.
    +
    dependent induction E.
    dependent destruction x...
    dependent destruction x...
    simpl in H0.
    inversion H0.
    destruct a.    
    simpl in *.
    constructor...
    *
      apply wf_env_decompose in H.
      destruct_hypos.
      inversion H0.
      apply combine_dom_dist with (k:=length (domE E))... 
      rewrite <- length_domE...
      apply notin_union...
      split...
      apply notin_domS_E...
      apply disjoint_subset_1 in H2...
    *
      apply wf_env_decompose in H.
      destruct_hypos.
      inversion H0.
      apply notin_union...
      split...
      apply disjoint_subset_2 in H2...
      apply combine_dom_dist with (k:=length (domE E))... 
      rewrite <- length_domE...
      apply notin_union...
      split...
      apply notin_domS_E...
      apply disjoint_subset_3 in H2...
      dependent destruction H1...
    *
      apply wf_env_decompose in H.
      destruct_hypos.
      apply IHE with (A:=A)...
      dependent destruction H1...
      apply disjoint_subset in H2...
      apply minus_add with (x:=a0)...
    +
      rewrite combind_domR...
      rewrite <- length_domE...
Qed.




Lemma monotone_length: forall E A B Em,
    monotone E A B Em ->
    length E = length Em.
Proof with auto.
  intros.
  induction H;simpl...
Qed.

Lemma env_conv_length: forall E  Em,
    env_conv E Em ->
    length E = length Em.
Proof with auto.
  intros.
  induction H;simpl...
Qed.

Definition flipEx (A : option Mode) : option Mode :=
  match A with
  | Some x => Some (flip x)
  | None => None
  end.


Lemma monotone_arrow: forall A1 A2 E B1 B2 Em,
    monotone E (typ_arrow A1 A2) (typ_arrow B1 B2) Em ->
    monotone E B1 A1 (List.map flip Em) /\ monotone E A2 B2 Em.
Proof with auto.
  intros.
  dependent induction H...
  -
    edestruct IHmonotone;eauto.
    dependent destruction H0.
    simpl in *.
    split...
    apply M_pos...
    apply M_neg...
  -
    edestruct IHmonotone;eauto.
    dependent destruction H0.
    simpl in *.
    split...
    apply M_neg...
    apply M_pos...
Qed.


Lemma wf_amber_weakening: forall E1 E2 E A ,
    wf_amber (E1 ++ E2) A ->
    wfe_amber (E1 ++ E ++ E2) ->
    wf_amber (E1 ++ E ++ E2) A.
Proof with auto.
  intros.
  generalize dependent E.
  dependent induction H;intros...
  -
    apply wfa_fvarl with (Y:=Y)...
    apply in_app_iff in H.
    destruct H.
    apply In_lemmaL...
    apply In_lemmaR...
    apply In_lemmaR...
  -
    apply wfa_fvarr with (X:=X)...
    apply in_app_iff in H.
    destruct H.
    apply In_lemmaL...
    apply In_lemmaR...
    apply In_lemmaR...
  -
    apply wfa_rec with (L:=L \u domA (E1 ++ E ++ E2)).
    intros...
    rewrite_alist (([(X, Y)] ++ E1) ++ E ++ E2)...
    apply H0 with (Y:=Y)...
    rewrite_alist ([(X, Y)] ++ E1 ++ E ++ E2)...
    constructor...
Qed.    
    
Lemma sub_amber_weakening: forall E1 E2 E A B,
    sub_amber (E1 ++ E2) A B ->
    wfe_amber (E1 ++ E ++ E2) ->
    sub_amber (E1 ++ E ++ E2) A B.
Proof with auto.
  intros.
  generalize dependent E.
  dependent induction H;intros...
  -
    constructor...
    apply wf_amber_weakening...
  -
    constructor...
    apply in_app_iff in H.
    destruct H.
    apply In_lemmaL...
    apply In_lemmaR...
    apply In_lemmaR...
  -
    apply sam_rec with (L:=L \u domA (E1++E++E2))...
    intros.
    rewrite_alist (([(X, Y)] ++ E1) ++ E ++ E2)...
    apply H0 with (Y:=Y)...
    rewrite_alist ([(X, Y)] ++ E1 ++ E ++ E2)...
    constructor...
  -
    constructor...
    apply wf_amber_weakening...
Qed.

Definition eqMode (a b: Mode)  : bool :=
  match a,b with
  | Pos, Pos => true
  | Neg, Neg => true
  | _,_ => false
  end.


Definition eqM (a: option Mode) (b: Mode) : bool :=
  match a with
  | None => false
  | Some a' => eqMode a' b
  end.


Fixpoint amber_cov (Ea : env_amber) (Em : env_mode) (T:typ) (m:Mode) : typ :=
  match Ea, Em with
  | (X,Y)::E, m'::Em' => if (eqMode m' m) then amber_cov E Em' (subst_tt X Y T) m
                         else amber_cov E Em' T m
  | _,_ => T
  end.


Lemma amber_cov_notin_invariance: forall Ea Em X m,
    X \notin domA Ea ->
    length Ea = length Em ->
    (amber_cov Ea Em (typ_fvar X) m) = X .
Proof with auto.
  intros.
  generalize dependent Em.
  induction Ea;intros...
  destruct Em...
  simpl in *.
  inversion H0.
  destruct a.
  simpl in *.
  inversion H0.
  destruct m0;destruct m;simpl...
  destruct (X==a)...
  assert (X <> a) by auto.
  destruct H1...
  destruct (X==a)...
  assert (X <> a) by auto.
  destruct H1...
Qed.

Lemma amber_cov_trans: forall Ea Em A1 A2 m,
    length Ea = length Em ->
    amber_cov Ea Em (typ_arrow A1 A2) m =
    typ_arrow (amber_cov Ea Em A1 m) (amber_cov Ea Em A2 m).
Proof with auto.
  intros Ea.
  induction Ea;intros...
  destruct Em...
  simpl in *.
  inversion H.
  destruct a.
  simpl in *.
  destruct m0;destruct m;simpl...
Qed.

Lemma amber_cov_flip: forall Ea Em T m,
    length Ea = length Em ->
    amber_cov Ea Em T m = amber_cov Ea (List.map flip Em) T (flip m).
Proof with auto.
  intros Ea.
  induction Ea;intros...
  destruct Em...
  destruct a.
  destruct m0;destruct m;simpl in *;
  apply IHEa...
Qed.

Lemma amber_cov_mu_invariance : forall Ea Em A m,
    length Ea = length Em ->
    amber_cov Ea Em (typ_mu A) m = typ_mu (amber_cov Ea Em A m).
Proof with auto.
  intros Ea.
  induction Ea;intros...
  destruct Em...
  inversion H.
  destruct a.
  inversion H...
  destruct m0;destruct m;simpl...
Qed.

Lemma amber_cov_nat_invariance : forall Ea Em m,
    length Ea = length Em ->
    amber_cov Ea Em typ_nat m = typ_nat.
Proof with auto.
  intros Ea.
  induction Ea;intros...
  destruct Em...
  inversion H.
  destruct a.
  inversion H...
  destruct m0;destruct m;simpl...
Qed.

Lemma amber_cov_top_invariance : forall Ea Em m,
    length Ea = length Em ->
    amber_cov Ea Em typ_top m = typ_top.
Proof with auto.
  intros Ea.
  induction Ea;intros...
  destruct Em...
  inversion H.
  destruct a.
  inversion H...
  destruct m0;destruct m;simpl...
Qed.

Lemma amber_cov_open_tt_invariance : forall Ea Em A m X,
    length Ea = length Em ->
    X \notin domA Ea ->
    amber_cov Ea Em (open_tt A (typ_fvar X)) m = open_tt (amber_cov Ea Em A m) (typ_fvar X).
Proof with auto.
  intros Ea.
  induction Ea;intros...
  destruct Em...
  inversion H.
  destruct a.
  inversion H...
  simpl in H0.
  destruct m0;destruct m;simpl...
  rewrite <- subst_tt_open_tt_var...
  rewrite <- subst_tt_open_tt_var...
Qed.

Lemma amber_cov_fv_empty : forall Ea Em A m,
    length Ea = length Em ->
    fv_tt A [=] {} ->
    amber_cov Ea Em A m = A .
Proof with auto.
  intros Ea.
  induction Ea;intros...
  destruct Em...
  inversion H.
  destruct a.
  inversion H...
  destruct m0;destruct m;simpl...
  rewrite <- subst_tt_fresh...
  rewrite H0...
  rewrite <- subst_tt_fresh...
  rewrite H0...
Qed.

Lemma subset_left_union: forall A B C,
    A \u B [<=] C ->
    A [<=] C /\ B [<=] C.
Proof with auto.
  intros.
  unfold "[<=]" in *.
  split;intros; apply H...
Qed.

Lemma type_wf_amber: forall A E,
    type A ->
    wfe_amber E ->
    fv_tt A [<=] domA E ->
    wf_amber E A.
Proof with auto.
  intros.
  generalize dependent E.
  induction H;intros...
  -
    induction E...
    simpl in *.
    unfold "[<=]" in H1.
    assert (X \in {{X}}) by auto.
    apply H1 in H.
    apply F.empty_iff in H.
    destruct H.
    destruct a.
    dependent destruction H0.
    simpl in *.
    destruct (X==a)...
    subst.
    apply wfa_fvarl with (Y:=a0)...
    apply in_eq...
    destruct (X==a0)...
    subst.
    apply wfa_fvarr with (X:=a)...
    apply in_eq...
    rewrite_alist (nil ++ [(a,a0)] ++ E).
    apply wf_amber_weakening...
    apply IHE...
    unfold "[<=]" in *.
    intros.
    assert (Ht:=H3).
    apply H2 in H3.
    apply D.F.singleton_iff in Ht.
    subst.
    apply union_iff in H3...
    destruct H3...
    apply D.F.singleton_iff in H3...
    destruct n...
     apply union_iff in H3...
    destruct H3...
    apply D.F.singleton_iff in H3...
    destruct n0...
    constructor...
  -
    simpl in H2.
    apply subset_left_union in H2...
    destruct_hypos...
  -
    apply wfa_rec with (L:=L \u domA E) .
    intros.
    apply H0...
    constructor...
    simpl in *...
    unfold "[<=]" in *...
    intros.
    apply in_open1 in H5.
    destruct H5...
Qed.

Lemma type_fvar_cov: forall Ea Em X m,
    length Ea = length Em ->
     type (amber_cov Ea Em (typ_fvar X) m).
Proof with auto.
  intros Ea.
  induction Ea;intros...
  destruct Em...
  simpl...
  inversion H...
  destruct Em...
  inversion H.
  inversion H.
  simpl...
  destruct a.
  destruct m0;destruct m;simpl...
  destruct (X==a)...
  destruct (X==a)...
Qed.

Lemma union_sigle_add: forall A B,
    add A B [=] {{A}} \u B.
Proof with auto.
  intros...
  unfold "[=]".
  intros...
  split;intros...
  apply add_iff in H.
  destruct H...
  apply union_iff in H...
  destruct H...
  apply singleton_iff in H...
Qed.  
  

Lemma amber_cov_fv_tt_subset: forall Ea Em X  E,
    binds X bind_sub E ->
    wf_env E ->
    length Ea = length Em ->
    env_conv E Ea -> wfe_amber Ea ->
    fv_tt (amber_cov Ea Em (typ_fvar X) Neg) [<=] domA Ea.
Proof with auto.  
  intros Ea.
  dependent induction Ea;intros...
  destruct Em...
  dependent destruction H2.
  analyze_binds H.
  inversion H1...
  destruct Em...
  inversion H1.
  inversion H1.
  dependent destruction H2.
  simpl...
  dependent destruction H3.
  destruct (X==X0)...
  -
    subst.
    destruct m;simpl...
    +
      rewrite amber_cov_notin_invariance...
      simpl...
      unfold "[<=]".
      intros...
    +
      rewrite amber_cov_notin_invariance...
      simpl...
      unfold "[<=]".
      intros...
  -
    destruct m;simpl...
    +
      analyze_binds H.
      apply wf_env_decompose in H0.
      destruct_hypos.
      rewrite <- union_sigle_add...
      apply KeySetProperties.subset_add_2...
      rewrite <- union_sigle_add...
      apply KeySetProperties.subset_add_2...
      apply IHEa with (E:=EX)...
    +
      analyze_binds H.
      apply wf_env_decompose in H0.
      destruct_hypos.
      rewrite <- union_sigle_add...
      apply KeySetProperties.subset_add_2...
      rewrite <- union_sigle_add...
      apply KeySetProperties.subset_add_2...
      apply IHEa with (E:=EX)...
Qed.


Lemma wf_amber_replacing: forall X Y E1 E2 A,
    wf_amber (E1 ++ [(X, Y)] ++ E2) A ->
    wfe_amber (E1 ++ [(X, Y)] ++ E2) ->
    wf_amber (E1 ++ [(X, Y)] ++ E2) (subst_tt Y X A).
Proof with auto.
  intros.
  dependent induction H;simpl in *...
  -
    destruct (X0==Y)...
    subst.
    apply wfa_fvarl with (Y:=Y)...
    apply In_lemmaR...
    apply in_eq...
    apply in_app_or in H.
    destruct H...
    apply wfa_fvarl with (Y:=Y0)...
    apply In_lemmaL...
    apply in_inv in H.
    destruct H...
    inversion H.
    subst.
    apply wfa_fvarl with (Y:=Y0)...
    apply In_lemmaR...
    apply in_eq...
    apply wfa_fvarl with (Y:=Y0)...
    apply In_lemmaR...
    rewrite_alist ([(X,Y)] ++ E2).
    apply In_lemmaR...
  -
    destruct (Y0==Y)...
    subst.
    apply wfa_fvarl with (Y:=Y)...
    apply In_lemmaR...
    apply in_eq...
    apply in_app_or in H.
    destruct H...
    apply wfa_fvarr with (X:=X0)...
    apply In_lemmaL...
    apply in_inv in H.
    destruct H...
    inversion H.
    subst.
    apply wfa_fvarr with (X:=X0)...
    apply In_lemmaR...
    apply in_eq...
    apply wfa_fvarr with (X:=X0)...
    apply In_lemmaR...
    rewrite_alist ([(X,Y)] ++ E2).
    apply In_lemmaR...
  -
    apply wfa_rec with (L:=L \u fv_tt A \u {{Y}} \u domA (E1 ++ (X, Y) :: E2)).
    intros.
    rewrite subst_tt_open_tt_var...
    rewrite_alist (([(X0, Y0)] ++ E1) ++ (X, Y) :: E2).
    apply H0 with (Y0:=Y0)...
    rewrite_alist ([(X0, Y0)] ++ E1 ++ (X, Y) :: E2)...
    constructor...
Qed.

Lemma amber_cov_notin_X: forall Ea X Em A m,
    X \notin fv_tt A \u domA Ea ->
    length Ea = length Em ->
    X \notin fv_tt (amber_cov Ea Em A m).
Proof with auto.
  intros Ea.
  induction Ea;intros...
  destruct Em...
  inversion H0...
  inversion H0.
  destruct a.
  simpl...
  destruct m0;destruct m;simpl in *...
  apply IHEa...
  apply notin_union.
  split...
  apply notin_fv_subst...
  apply IHEa...
  apply notin_union.
  split...
  apply notin_fv_subst...
Qed.  
  
Lemma amber_cov_wf_amber: forall E A,
    WF E A -> forall Ea   Em,
      env_conv E Ea ->
      wf_env E -> length Ea = length Em ->
      wfe_amber Ea ->
    wf_amber Ea (amber_cov Ea Em A Neg).
Proof with auto.
  intros E A H.
  induction H;intros...
  -
    rewrite amber_cov_top_invariance...
  -
    rewrite amber_cov_nat_invariance...
  -
    apply type_wf_amber...
    apply type_fvar_cov...
    apply amber_cov_fv_tt_subset with (E:=E)...
  -
    rewrite amber_cov_trans...
  -
    rewrite amber_cov_mu_invariance...
    apply wfa_rec with (L:=L \u domA Ea \u dom E \u fv_tt A) ...
    intros.
    specialize_x_and_L X L.
    specialize (H0  ((X,Y)::Ea)  ( Neg::Em) ).
    assert (wf_amber ((X, Y) :: Ea) (amber_cov ((X, Y) :: Ea) ( Neg :: Em) (open_tt A X) Neg)).
    apply H0...
    simpl...
    simpl in *.
    rewrite <- subst_tt_intro in H9...
    rewrite  amber_cov_open_tt_invariance in H9...
    rewrite subst_tt_intro with (X:=Y)...
    rewrite_alist (nil ++ [(X, Y)] ++ Ea).
    apply wf_amber_replacing...
    constructor...
    apply amber_cov_notin_X...
Qed.

Lemma domA_dec: forall a E,
    wfe_amber E ->
    a \in domA E \/ a \notin domA E.
Proof with auto.
  intros.
  induction E...
  destruct a0;simpl...
  dependent destruction H.
  apply IHE in H1.
  destruct H1...
  destruct (a==a0)...
  destruct (a==a1)...
Qed.

Lemma notin_fv_rev: forall T X (Y : atom) k,
    X \notin fv_tt (open_tt_rec k Y T) ->
    X <> Y->
    X \notin fv_tt T.
Proof with auto.
  intros T.
  induction T;intros...
  simpl in *.
  apply IHT with (Y:=Y) (k:=S k)...
  simpl in *...
  apply notin_union in H.
  destruct H...
  apply notin_union.
  split...
  eapply IHT1...
  eapply IHT2...
Qed.  

Lemma posvar_exclude: forall A ,
    type A ->
    forall X,
      posvar Pos X A A ->
      posvar Neg X A A ->
      X \notin fv_tt A  \/ False.
Proof with auto.
  intros A H.
  induction H;intros...
  -
    dependent destruction H...
    dependent destruction H0...
  -
    dependent destruction H1.
    dependent destruction H2.
    simpl in *.
    specialize (IHtype1 _ H2_ H1_).
    specialize (IHtype2 _ H1_0 H2_0).
    destruct IHtype1;destruct IHtype2...
  -
    dependent destruction H2;
    dependent destruction H1.
    +
      pick fresh Y.
      specialize_x_and_L Y L.
      specialize_x_and_L Y (L0 \u {{X}}).
      specialize_x_and_L Y (L1 \u {{X}})...
      specialize (H0 _ H1 H3).
      destruct H0...
      left...
      simpl in *...
      apply notin_fv_rev in H0...
    +
      pick fresh Y.
      specialize_x_and_L Y L.
      specialize_x_and_L Y (L1 \u {{X}})...
    +
      pick fresh Y.
      specialize_x_and_L Y L.
      specialize_x_and_L Y (L0 \u {{X}})...
    +
      pick fresh Y.
      specialize_x_and_L Y L.
      specialize_x_and_L Y (L0 \u {{X}}).
      specialize_x_and_L Y (L1 \u {{X}})...
Qed.

                      

(*
A = (mu Y. X -> Y) -> nat.
B = (mu Y. X -> Y) -> top.
posvar X Pos (open_tt A X).
posvar X Pos (open_tt B X).
       
posvar X Neg ( X -> Y).
posvar Y Pos ( X -> Y).

sub_amber (mu X . A) (mu X . B).
monotone X Neg
          
   
 *)

  
Lemma posvar_dec: forall A,
    type A -> forall X m,
      posvar m X A A \/ ~ posvar m X A A.
Proof with auto.
  intros A H.
  induction H;intros...
  -
    destruct (X==X0)...
    subst.
    destruct m...
    right.
    intros v.
    inversion v...
  -
    destruct IHtype1 with (X:=X) (m:=flip m);
      destruct IHtype2 with (X:=X) (m:=m)...
    right.
    intros v.
    dependent destruction v.
    apply H2...
    right.
    intros v.
    dependent destruction v.
    apply H1...
    right.
    intros v.
    dependent destruction v.
    apply H2...
  -
    destruct (KeySetProperties.In_dec X (fv_tt T)).
    +
      pick fresh Y.
      destruct H0 with (X:=Y) (m:=m) (X0:=X);
        destruct H0 with (X:=Y) (m:=Pos) (X0:=Y)...
      *
        left.
        apply pos_rec with (L:= fv_tt T \u {{X}} \u {{Y}})...
        intros.
        rewrite subst_tt_intro with (X:=Y)...
        apply pos_rename_fix...
        intros.
        rewrite subst_tt_intro with (X:=Y)...
        apply pos_rename_1...
        apply notin_union.
        split...
        apply notin_union.
        split;apply notin_fv_tt_open_aux...
      *
        right.
        intros v.
        dependent destruction v.
        pick fresh Z.
        apply H2.
        rewrite subst_tt_intro with (X:=Z)...
        apply pos_rename_1...
        apply notin_union.
        split...
        apply notin_union.
        split;apply notin_fv_tt_open_aux...
        apply H3...
      *
        right.
        intros v.
        dependent destruction v.
        pick fresh Z.
        apply H1.
        rewrite subst_tt_intro with (X:=Z)...
        apply pos_rename_fix...
        apply H3...
      *
        right.
        intros v.
        dependent destruction v.
        pick fresh Z.
        apply H2.
        rewrite subst_tt_intro with (X:=Z)...
        apply pos_rename_1...
        apply notin_union.
        split...
        apply notin_union.
        split;apply notin_fv_tt_open_aux...
        apply H3...
    +
      left.
      apply pos_rec_t with (L:=L)...
Qed.      

Lemma monotone_mu: forall E Em A B X,
    monotone E (typ_mu A) (typ_mu B) Em ->
    (X \notin dom E -> monotone E (open_tt A X) (open_tt B X) Em).
Proof with auto.
  intros.
  generalize dependent X.
  dependent induction H...
  -
    intros.
    constructor...
    dependent destruction H0...
    pick fresh Y.
    rewrite subst_tt_intro with (X:=Y)...
    remember (subst_tt Y X0 (open_tt A Y)) .
    rewrite subst_tt_intro with (X:=Y)...
    subst.
    apply pos_rename_fix...
    apply posvar_self_notin...
    pick fresh Y.
    rewrite subst_tt_intro with (X:=Y)...
    apply subst_tt_type...
    apply notin_fv_tt_open_aux...
  -
    intros.
    constructor...
    dependent destruction H0...
    pick fresh Y.
    rewrite subst_tt_intro with (X:=Y)...
    remember (subst_tt Y X0 (open_tt A Y)) .
    rewrite subst_tt_intro with (X:=Y)...
    subst.
    apply pos_rename_fix...
    apply posvar_self_notin...
    pick fresh Y.
    rewrite subst_tt_intro with (X:=Y)...
    apply subst_tt_type...
    apply notin_fv_tt_open_aux...
Qed.



Lemma pos_rename_open: forall m X A B Y,
    posvar m X (open_tt A X) (open_tt B X) ->
    X \notin {{Y}} \u fv_tt A \u fv_tt B ->
    Y \notin fv_tt A \u fv_tt B ->
    posvar m Y (open_tt A Y) (open_tt B Y).
Proof with auto.
  intros.
  rewrite subst_tt_intro with (X:=X)...
    remember (subst_tt X Y (open_tt A X)).
    rewrite subst_tt_intro with (X:=X)...
    subst.
    apply pos_rename_1...
    apply notin_union.
    split...
    apply notin_union.
    split;apply notin_fv_tt_open_aux...
Qed.

Fixpoint isBindsub (E:env) : Prop :=
  match E with
  | nil => True
  | (a,bind_sub)::E' => isBindsub E'
  | _ => False
  end.

Lemma length_flip: forall Em,
    length Em = length (List.map flip Em).
Proof with auto.  
  intros...
  induction Em...
  simpl...
Qed.

Lemma monotone_notin: forall E,
    isBindsub E ->
    forall  A Y  Em,
      (forall X, X `in` fv_tt A -> 
       X \notin dom E) ->
       length E = length Em ->
  posvar Pos Y A A -> Y \notin dom E ->
  monotone E A A Em. 
Proof with auto.
  intros E .
  induction E;intros...
  -
    destruct Em;try solve [inversion H1].
    constructor...
  -
    destruct Em;try solve [inversion H1].
    destruct a...
    destruct b;simpl in *;try solve [destruct H]...
    destruct m...
    +
      constructor...
      apply IHE with (Y:=Y)...
      intros.
      apply H0 in H4.
      apply notin_add_2 in H4...
      apply pos_rename_3 with (m:=Pos) (X:=Y)...
      apply notin_union.
      split.
      apply notin_add_1 in H3...
      assert (a \notin fv_tt A \/ a \in fv_tt A).
      apply in_dec...
      destruct H4...
      apply H0 in H4.
      apply notin_add_1 in H4...
    +  
      constructor...
      apply IHE with (Y:=Y)...
      intros.
      apply H0 in H4.
      apply notin_add_2 in H4...
      apply pos_rename_3 with (m:=Pos) (X:=Y)...
      apply notin_union.
      split.
      apply notin_add_1 in H3...
      assert (a \notin fv_tt A \/ a \in fv_tt A).
      apply in_dec...
      destruct H4...
      apply H0 in H4.
      apply notin_add_1 in H4...
Qed.      

Lemma monotone_bindsub: forall E A B Em,
    monotone E A B Em -> isBindsub E.
Proof with auto.
  intros.
  induction H...
  constructor...
Qed.

Ltac mytact1:= apply notin_union;split;auto;apply notin_union;
               split;apply notin_fv_tt_open_aux;auto.


Lemma monotone_rec: forall E Em A B X,
    monotone E (typ_mu A) (typ_mu B) Em ->
    posvar Pos X (typ_mu A) (typ_mu B) ->
    wf_env E -> 
    (A = B /\ minus (fv_tt A) (dom E) /\ X \notin fv_tt A) \/
    (X \notin fv_tt A \u fv_tt B \u dom E ->
     monotone E (open_tt A X) (open_tt B X) Em /\ posvar Pos X (open_tt A X) (open_tt B X)).
Proof with auto.
  intros.
  generalize dependent X.
  dependent induction H...
  -
    intros.
    dependent destruction H0...
    right...
    intros.
    split...
    pick fresh Y.
    specialize_x_and_L Y (L \u {{X}}).
    apply pos_rename_open with (X:=Y)...
    left.
    split...
    split...
    unfold minus...    
  -    
    intros.
    dependent destruction H0...
    +
      dependent destruction H2.
      destruct IHmonotone with (X:=X0) (A0:=A) (B0:=B)...
      *
        right.
        intros.
        pick fresh Z.
        specialize_x_and_L Z (L \u {{X}}).
        destruct_hypos.
        subst.
        assert (posvar Pos X0 (open_tt B X0) (open_tt B X0)).
        {
          rewrite subst_tt_intro with (X:=Z)...
          apply pos_rename_1...
          mytact1...
        }
        split...
        constructor...
        apply monotone_notin with (Y:=Z)...
        apply monotone_bindsub in H...
        intros.
        apply in_open1 in H9.
        destruct H9.
        simpl in *.
        apply singleton_iff in H9...
        subst...
        apply H7...
        apply monotone_length in H...
        rewrite subst_tt_intro with (X:=Z)...
        apply pos_rename_2...
        mytact1...
        rewrite subst_tt_intro with (X:=Z)...
        apply pos_rename_fix...
      *
        right.
        intros.
        destruct H5...
        split...
        constructor...
        pick fresh Z.
        specialize_x_and_L Z (L \u {{X}}).
        rewrite subst_tt_intro with (X:=Z)...
        remember (subst_tt Z X0 (open_tt A Z)).
        rewrite subst_tt_intro with (X:=Z)...
        subst.
        apply pos_rename_fix...
    +
      dependent destruction H2.
      destruct IHmonotone with (X:=X0) (A:=B) (B0:=B)...
      *
        left.
        destruct_hypos.
        split...
        split...
        unfold minus in *.
        intros...
        simpl...
        apply notin_add...
        apply in_notin with (Y:=X) in H8...
      *
        right.
        intros.
        simpl in *.
        destruct H5...
        split...
        constructor...
        apply posvar_self_notin...
        apply posvar_regular in H7...
        destruct_hypos...
        apply notin_fv_tt_open_aux...
  -
    intros.
    dependent destruction H0...
    +
      dependent destruction H2.
      destruct IHmonotone with (X:=X0) (A0:=A) (B0:=B)...
      *
        right.
        intros.
        pick fresh Z.
        specialize_x_and_L Z (L \u {{X}}).
        destruct_hypos.
        subst.
        assert (posvar Pos X0 (open_tt B X0) (open_tt B X0)).
        {
          rewrite subst_tt_intro with (X:=Z)...
          apply pos_rename_1...
          mytact1...
        }
        split...
        constructor...
        apply monotone_notin with (Y:=Z)...
        apply monotone_bindsub in H...
        intros.
        apply in_open1 in H9.
        destruct H9.
        simpl in *.
        apply singleton_iff in H9...
        subst...
        apply H7...
        apply monotone_length in H...
        rewrite subst_tt_intro with (X:=Z)...
        apply pos_rename_2...
        mytact1...
        rewrite subst_tt_intro with (X:=Z)...
        apply pos_rename_fix...
      *
        right.
        intros.
        destruct H5...
        split...
        constructor...
        pick fresh Z.
        specialize_x_and_L Z (L \u {{X}}).
        rewrite subst_tt_intro with (X:=Z)...
        remember (subst_tt Z X0 (open_tt A Z)).
        rewrite subst_tt_intro with (X:=Z)...
        subst.
        apply pos_rename_fix...
    +
      dependent destruction H2.
      destruct IHmonotone with (X:=X0) (A:=B) (B0:=B)...
      *
        left.
        destruct_hypos.
        split...
        split...
        unfold minus in *.
        intros...
        simpl...
        apply notin_add...
        apply in_notin with (Y:=X) in H8...
      *
        right.
        intros.
        simpl in *.
        destruct H5...
        split...
        constructor...
        apply posvar_self_notin...
        apply posvar_regular in H7...
        destruct_hypos...
        apply notin_fv_tt_open_aux...
Qed.

Lemma minus_add_notin: forall A x B,
    minus A (add x B) ->
    x \notin A.
Proof with auto.
  intros.
  unfold minus in H.
  assert (x \notin A \/ x \in A).
  apply in_dec...
  destruct H0...
  apply H in H0...
Qed.  

Lemma amber_cov_minus : forall Ea A Em m,
    minus (fv_tt A) (domL Ea) ->
    minus (fv_tt A) (domR Ea) ->
    length Ea = length Em -> 
    amber_cov Ea Em A m = A.
Proof with auto.
  intros Ea.
  induction Ea;intros...
  destruct Em...
  inversion H1...
  destruct a.
  simpl in *.
  assert (Q1:=H).
  apply minus_add in Q1.
  assert (Q2:=H0).
  apply minus_add in Q2.
  apply minus_add_notin in H.
  apply minus_add_notin in H0.
  destruct m0;destruct m;simpl ...
  rewrite <- subst_tt_fresh ...
  rewrite <- subst_tt_fresh ...
Qed.  
  
Lemma minus_union: forall A B C,
    minus (A \u B) C ->
    minus A C /\ minus B C.
Proof with auto.
  intros.
  unfold minus in *.
  split...
Qed.

Lemma env_conv_fresh_var: forall E Ea X,
    env_conv E Ea ->
    binds X bind_sub E ->
    exists Y, In (X,Y) Ea.
Proof with auto.
  intros E.
  induction E;intros...
  inversion H0.
  dependent destruction H.
  analyze_binds H0.
  exists Y...
  apply in_eq...
  apply IHE with (X:=X) in H...
  destruct_hypos.
  exists x...
  rewrite_alist ([(X0,Y)] ++ EY).
  apply In_lemmaR...
Qed.  

Lemma env_conv_wf_amber: forall E Ea A ,
    WF E A ->
    env_conv E Ea ->
    wfe_amber Ea ->
    wf_amber Ea A.
Proof with auto.
  intros.
  generalize dependent Ea.
  induction H;intros...
  -
    apply env_conv_fresh_var with (X:=X) in H0...
    destruct H0.
    apply wfa_fvarl with (Y:=x)...
  -
    apply wfa_rec with (L:=L \u domA Ea)...
    intros.
    apply H0...
    constructor...
    constructor...
Qed.

Lemma domE_domL_eq: forall Ea E,
    env_conv E Ea ->
    dom E = domL Ea.
Proof with auto.
  intros Ea.
  induction Ea;intros...
  dependent destruction H...
  dependent destruction H...
  simpl...
  f_equal...
Qed.  

Lemma monotone_subst: forall E Em A B X Y,
    monotone E A B Em ->
    X \notin dom E ->
    Y \notin {{X}} \u dom E ->
    monotone E (subst_tt X Y A) (subst_tt X Y B) Em.
Proof with auto.
  intros.
  induction H...
  -
    constructor...
    apply pos_rename_fix...
  -
    constructor...
    apply pos_rename_fix...
Qed.

Lemma minus_domR: forall A B (X Y :atom),
    minus (fv_tt A) B ->
    Y \notin fv_tt A \u {{X}} ->
    X \notin B ->
    minus (fv_tt (open_tt A X)) (add Y B).
Proof with auto.
  intros.
  unfold minus in *.
  intros.
  apply in_open1 in H2.
  destruct H2...
  simpl in *.
  apply F.singleton_iff in H2.
  subst.
  apply notin_add...
  apply notin_add...
  apply in_notin with (Y:=Y) in H2...
Qed.

Lemma notin_domA_to_R: forall E X,
    X \notin domA E ->
    X \notin domR E.
Proof with auto.
  intros E.
  induction E;intros...
  destruct a.
  simpl in *...
Qed.  

Theorem amber_complete_aux: forall E A B,
    sub_amber2 E A B ->
    forall  Em Ea,
      monotone E A B Em ->
      env_conv E  Ea -> wfe_amber Ea ->
      length Ea = length Em -> minus (fv_tt A) (domR Ea) ->  minus (fv_tt B) (domR Ea) ->
    sub_amber Ea (amber_cov Ea Em A Neg) (amber_cov Ea Em B Pos) . 
Proof with auto.
  intros E A B H.
  assert (Hq:=H).
  apply suba2_regular in Hq.
  induction H;intros...
  -
    rewrite  amber_cov_nat_invariance...
    rewrite  amber_cov_nat_invariance...
  -
    rewrite  amber_cov_top_invariance...
    constructor...
    apply amber_cov_wf_amber with (E:=E)...   
  -
    generalize dependent Ea.
    dependent induction H1;intros...
    +
      analyze_binds H.
    +
      dependent destruction H3.
      simpl in *...
      destruct (X==X0)...
      *
        subst.
        dependent destruction H2...
        destruct H0...
      *
        rewrite_alist (nil ++ [(X0, Y)] ++ EY).
        apply sub_amber_weakening...
        apply wf_env_decompose in H0.
        dependent destruction H4.
        analyze_binds H.
        destruct_hypos.
        apply IHmonotone with (E:=E0)...
        apply minus_add in H8...
        apply minus_add in H8...
    +
      dependent destruction H3.
      simpl in *...
      destruct (X==X0)...
      *
        subst.
        apply wf_env_decompose in H0.
        dependent destruction H4.
        destruct_hypos.
        inversion H7.
        rewrite amber_cov_notin_invariance...
        rewrite amber_cov_notin_invariance...
        constructor...
        apply in_eq...
      *
        rewrite_alist (nil ++ [(X0, Y)] ++ EY).
        apply sub_amber_weakening...
        apply wf_env_decompose in H0.
        dependent destruction H4.
        analyze_binds H.
        destruct_hypos.
        apply IHmonotone with (E:=E0)...
        apply minus_add in H8...
        apply minus_add in H8...
  -
    simpl in *.
    apply minus_union in H5.
    apply minus_union in H6.
    destruct_hypos.
    dependent destruction H10.
    dependent destruction H11.
    apply monotone_arrow in H1.
    destruct_hypos.
    rewrite amber_cov_trans...
    rewrite amber_cov_trans...
    constructor...
    rewrite amber_cov_flip...
    remember (amber_cov Ea (List.map flip Em) B1 (flip Pos)).
    rewrite amber_cov_flip...
    subst.
    simpl in *...
    apply IHsub_amber2_1...
    rewrite H4...
    rewrite length_flip...
  -
    pick fresh Z.
    assert (Ht:=H2).
    destruct_hypos.
    apply monotone_rec with (X:=Z) in H2...
    destruct H2.
    +
      destruct_hypos.
      subst.
      rewrite amber_cov_minus...
      rewrite amber_cov_minus...
      apply sam_refl...
      apply env_conv_wf_amber with (E:=E)...
      rewrite <- domE_domL_eq with (E:=E)...
      rewrite <- domE_domL_eq with (E:=E)...
    +
      destruct_hypos.
      dependent destruction H9.
      dependent destruction H10.
      destruct H4...
      rewrite  amber_cov_mu_invariance...
      rewrite  amber_cov_mu_invariance...
      apply sam_rec with (L:=L \u L0 \u L1 \u domA Ea \u dom E \u fv_tt A \u fv_tt B \u {{Z}}).
      intros.
      rewrite <- amber_cov_open_tt_invariance...
      rewrite <- amber_cov_open_tt_invariance...
      specialize_x_and_L X L.
      assert (sub_amber ((X, Y) :: Ea) (amber_cov ((X, Y) :: Ea) ( Pos :: Em) (open_tt A X) Neg)
                        (amber_cov ((X, Y) :: Ea) ( Pos :: Em) (open_tt B X) Pos)).
      {
        apply H0...
        constructor...
        rewrite subst_tt_intro with (X:=Z)...
        remember (subst_tt Z X (open_tt A Z)).
        rewrite subst_tt_intro with (X:=Z)...
        subst.
        apply  monotone_subst...
        apply pos_rename_open with (X:=Z)...
        simpl...
        simpl in *.
        apply minus_domR...
        apply notin_domA_to_R...
        simpl in *.
        apply minus_domR...
        apply notin_domA_to_R...
      }  
      simpl in H14...
      rewrite <- subst_tt_intro in H14...
Qed.



      
Theorem amber_complete': forall  A B,
    sub_amber2 nil A B ->
    sub_amber nil (amber_cov nil nil A Neg) (amber_cov nil nil B Pos) . 
Proof with auto.
  intros.
  apply amber_complete_aux with (E:=nil)...
  unfold minus...
  unfold minus...
Qed.


Theorem amber_complete: forall  A B,
    sub nil A B ->
    sub_amber nil (amber_cov nil nil A Neg) (amber_cov nil nil B Pos) . 
Proof with auto.
  intros.
  apply amber_complete_aux with (E:=nil)...
  apply sub_to_amber2...
  unfold minus...
  unfold minus...
Qed.

Corollary amber_complete2: forall  A B,
    Sub nil A B ->
    sub_amber nil (amber_cov nil nil A Neg) (amber_cov nil nil B Pos) . 
Proof with auto.
  intros.
  apply amber_complete...
  apply completeness  in H...
Qed.

Corollary amber_transitivity: forall A B C,
    sub_amber nil A B ->
    sub_amber nil B C ->
    sub_amber nil A C.
Proof with auto.
  intros.
  apply amber_soundness in H.
  apply amber_soundness in H0.
  apply amber_complete.
  simpl in *.
  apply trans_algo with (B:=B)...
Qed.


Corollary amber_unfolding: forall A B ,
    sub_amber nil (typ_mu A) (typ_mu B) ->
    sub_amber nil (open_tt A (typ_mu A)) (open_tt B (typ_mu B)).
Proof with auto.
  intros.
  apply amber_soundness in H.
  apply unfolding_lemma_version2 in H.
  simpl in *.
  
  apply amber_complete in H...
Qed.
