Require Import Metalib.Metatheory.
Require Import Program.Equality.
Require Export FiniteUnfolding.


Lemma strengthening_wf: forall E1 E2 T X m,
    WF (E1 ++ X ~ m ++ E2) T->
    X \notin fv_tt T ->
    WF (E1 ++ E2) T.
Proof with auto.
  intros.
  dependent induction H...
  -
    analyze_binds H...
    simpl.
    apply D.F.singleton_iff...
  -
    simpl in H1.
    constructor...
    apply IHWF1 with (X0:=X) (m0:=m)...
    apply IHWF2 with (X0:=X) (m0:=m)...
  -
    simpl in H1.
    apply WF_rec with (L:=L \u {{X}}).
    intros.
    rewrite_alist (([(X0, bind_sub)] ++ E1) ++ E2).
    apply H0 with (X1:=X) (m0:=m)...
    apply notin_fv_tt_open_aux...
    intros.
    rewrite_alist (([(X0, bind_sub)] ++ E1) ++ E2).
    apply H2 with (X1:=X) (m0:=m)...
    apply notin_fv_tt_open_aux...
    apply notin_fv_tt_open_aux...
Qed.   

Lemma strengthening_sa: forall E1 E2 A B X m,
    sub (E1 ++ X ~ m ++ E2) A B ->
    X \notin (fv_tt A \u fv_tt B) ->
    wf_env  (E1 ++ E2 ) ->
    sub (E1 ++ E2) A B.
Proof with auto.
  intros.
  dependent induction H...
  -
    constructor...
    analyze_binds H0...
    apply AtomSetImpl.union_2.
    apply D.F.singleton_iff...
  -
    constructor...
    apply strengthening_wf with (X:=X) (m:=m)...
  -
    simpl in H1.
    constructor...
    apply IHsub1 with (X0:=X) (m0:=m)...
    apply IHsub2 with (X0:=X) (m0:=m)...
  -
    simpl in H1.
    apply sa_rec with (L:=L \u {{X}} \u dom (E1 ++ E2)).
    intros.
    rewrite_alist (([(X0, bind_sub)] ++ E1) ++ E2).
    apply H0 with (X1:=X) (m0:=m)...
    apply notin_union.
    split.
    apply notin_fv_tt_open_aux...
    apply notin_fv_tt_open_aux...
    rewrite_alist ([(X0, bind_sub)] ++ E1 ++ E2).
    constructor...
    intros.
    rewrite_alist (([(X0, bind_sub)] ++ E1) ++ E2).
    apply H2 with (X1:=X) (m0:=m)...
    apply notin_union.
    split.
    apply notin_fv_tt_open_aux...
    apply notin_fv_tt_open_aux...
    apply notin_fv_tt_open_aux...
    apply notin_fv_tt_open_aux...
    rewrite_alist ([(X0, bind_sub)] ++ E1 ++ E2).
    constructor...
Qed.

Lemma chooseS_open: forall C X D  A (Y : atom) m,
    X <> Y ->
    type D -> type C ->
    chooseS m X C D (open_tt A Y) = open_tt (chooseS m X C D A) Y.
Proof with auto.
  intros.
  unfold chooseS.
  destruct m...
  rewrite subst_tt_open_tt...
  f_equal...
  rewrite <- subst_tt_fresh ...
  rewrite subst_tt_open_tt...
  f_equal...
  rewrite <- subst_tt_fresh ...
Qed.


Lemma chooseS_open2: forall C X D  A (Y : atom) m,
    X <> Y ->
    type D -> type C ->
    chooseS m X C D (open_tt A (open_tt A Y)) = open_tt (chooseS m X C D A) (open_tt (chooseS m X C D A) Y).
Proof with auto.
  intros.
  unfold chooseS.
  destruct m.
  rewrite subst_tt_open_tt ...
  f_equal...
  rewrite subst_tt_open_tt_var...
  rewrite subst_tt_open_tt ...
  f_equal...
  rewrite subst_tt_open_tt_var...
Qed.




Lemma wf_type: forall E A,
    WF E A -> type A.
Proof with auto.
  intros.
  induction H...
  apply type_mu with (L:=L)...
Qed.

Ltac specialize_x_and_L X L :=
  repeat match goal with
         | [H : forall _, _ \notin L -> _, Q : X \notin L |- _ ] => specialize (H _ Q); clear Q
         | [H : forall _, _ \notin L -> _ |- _ ] => assert (X \notin L) by auto
         end.

Ltac wfs_to_type :=
  match goal with
  | [H: WF ?E ?A |- type ?A] =>  apply wf_type in H; assumption
  | [H: WFS ?E ?A |- type ?A] =>  apply wfs_type in H; assumption
  end.

Lemma wf_weakening: forall E1 E2 T E,
    WF (E1 ++ E2) T ->
    WF (E1 ++ E ++ E2) T.
Proof with auto.
  intros.
  generalize dependent E.
  dependent induction H;intros...
  -
    apply WF_rec with (L:=L)...
    intros.
    rewrite_alist (([(X, bind_sub)] ++ E1) ++ E ++ E2).
    apply H0...
    intros.
    rewrite_alist (([(X, bind_sub)] ++ E1) ++ E ++ E2).
    apply H2...
Qed.

Lemma subst_tt_wf: forall E A B X,
    WF E A ->
    WF E B ->
    WF E (subst_tt X A B).
Proof with auto.
  intros.
  generalize dependent A.
  induction H0;intros...
  -
    simpl.
    destruct (X0==X)...
  -
    simpl...
  -
    simpl...
    assert (type A0).
    apply wf_type in H3...
    apply WF_rec with (L:=L \u {{X}});intros...
    +
      rewrite subst_tt_open_tt_var...
      apply H0...
      rewrite_alist (nil ++ [(X0, bind_sub)] ++ E).
      apply wf_weakening...
    +
      rewrite  subst_tt_open_tt_var...
      rewrite <- subst_tt_open_tt...
      apply H2...
      rewrite_alist (nil ++ [(X0, bind_sub)] ++ E).
      apply wf_weakening...
Qed.    

Lemma sub_weakening: forall E E1 E2 A B,
    sub (E1++E2) A B ->
    wf_env (E1 ++ E ++ E2) ->
    sub (E1++E++E2) A B.
Proof with auto.
  intros.
  generalize dependent E.
  dependent induction H;intros...
  -
    constructor...
    apply wf_weakening...
  -
    apply sa_rec with (L:=L \u dom (E1 ++ E ++ E2))...
    intros.
    rewrite_alist (([(X, bind_sub)] ++ E1) ++ E ++ E2).
    apply H0...
    rewrite_alist ([(X, bind_sub)] ++ E1 ++ E ++ E2)...
    intros.
    rewrite_alist (([(X, bind_sub)] ++ E1) ++ E ++ E2)...
    apply H2...
    rewrite_alist ([(X, bind_sub)] ++ E1 ++ E ++ E2)...
Qed.


Lemma sub_eq : forall A B E,
    sub E A B -> sub E B A -> A = B.
Proof with auto.
  induction 1; intros; simpl in *; eauto.
  -
    dependent destruction H1; eauto.
  -
    dependent destruction H1.
    rewrite IHsub1; eauto.
    rewrite IHsub2; eauto.
  -
    dependent destruction H3.
    f_equal.
    pick fresh X.
    apply open_rec_eq with (X:=X) (n:=0)...
    unfold open_tt in *...
    apply H0...
    apply H3...
Qed.

Lemma type_mu_open: forall A X,
    X \notin fv_tt A ->
    type (typ_mu A) ->
    type (open_tt A X).
Proof with auto.
  intros.
  dependent destruction H0.
  pick fresh Y.
  assert (Y \notin L) by auto.
  specialize (H0 _ H1).
  rewrite subst_tt_intro with (X:=Y)...
  apply subst_tt_type...
Qed.

Lemma subst_tt_wf2: forall A B E1 E2 X,
    WF (E1 ++ E2) A ->
    WF (E1 ++ (X ~ bind_sub) ++ E2) B ->
    WF (E1 ++ E2) (subst_tt X A B).
Proof with auto.
  intros.
  generalize dependent A.
  dependent induction H0;intros;simpl in *...
  -
    destruct (X0==X)...
    analyze_binds H.
  -
    assert (type A0).
    apply wf_type in H3...
    apply WF_rec with (L:=L \u {{X}} \u fv_tt A0);intros...
    +
      rewrite  subst_tt_open_tt_var...
      rewrite_alist (([(X0, bind_sub)] ++ E1) ++ E2).
      apply H0...
      rewrite_alist (nil ++ [(X0, bind_sub)] ++ (E1 ++ E2)).
      apply wf_weakening...
    +
      rewrite  subst_tt_open_tt_var...
      rewrite <- subst_tt_open_tt...
      rewrite_alist (([(X0, bind_sub)] ++ E1) ++ E2).
      apply H2...
      rewrite_alist (nil ++ [(X0, bind_sub)] ++ (E1 ++ E2)).
      apply wf_weakening...
Qed.

Lemma sub_generalize_intensive : forall E1 E2 A B X,
    sub (E1 ++ X ~ bind_sub ++ E2) A B ->
    forall C D  m,
      sub  (E1 ++ X ~ bind_sub ++ E2) (open_tt C X) (open_tt D X) ->
      X \notin fv_tt C \u fv_tt D -> 
      sub (E1 ++ X ~ bind_sub ++ E2) (chooseS m X (open_tt C X) (open_tt D X) A) (chooseS m X (open_tt D X) (open_tt C X) B) ->
      sub (E1 ++ E2) (typ_mu C) (typ_mu D) ->                  
    sub (E1 ++ E2) (chooseS m X (typ_mu C) (typ_mu D) A) (chooseS m X (typ_mu D) (typ_mu C) B).
Proof with auto.
  intros.
  assert (wf_env (E1++E2)) as Q.
  apply suba_regular in H3.
  destruct_hypos...
  dependent induction H; simpl in *; eauto.
  -
    destruct m; unfold chooseS; eauto.
  -
    destruct m; simpl in *; subst; eauto; destruct (X0 == X); simpl in *; eauto.
    subst.
    apply sub_eq in H3...
    unfold open_tt in H3.
    apply open_rec_eq in H3...
    subst.
    apply refl_algo...
    apply suba_regular in H4...
    destruct_hypos...
    apply soundness_wf...
    constructor...
    analyze_binds H0...
    constructor...
    analyze_binds H0...
  -
    destruct m; unfold chooseS; simpl in *; eauto.
    +
      constructor...
      apply subst_tt_wf2...
      apply suba_regular in H4.
      destruct_hypos...
    +
      constructor...
      apply subst_tt_wf2...
      apply suba_regular in H4.
      destruct_hypos...
  -
    rewrite chooseS_arrow.
    rewrite chooseS_arrow.
    rewrite chooseS_arrow in H3.
    rewrite chooseS_arrow in H3.
    dependent destruction H3.
    constructor...
    eapply IHsub1 with (m:=flip m) in H1; eauto.
    destruct m; simpl in *; eauto.
    destruct m; simpl in *; eauto.
  -
    rewrite chooseS_mu.
    rewrite chooseS_mu.
    rewrite chooseS_mu in H5.
    rewrite chooseS_mu in H5.
    dependent destruction H5.
    
    assert (wf_env (E1 ++ E2) /\ type (typ_mu C) /\ type (typ_mu D)).
    {
      apply suba_regular in H7.
      destruct_hypos.
      apply wf_type in H8.
      apply wf_type in H9.
      split...
    }
    destruct_hypos.
    assert (type (open_tt C X)).
    apply type_mu_open...
    assert (type (open_tt D X)).
    apply type_mu_open...
    
    apply sa_rec with (L := L \u L0 \u fv_tt A1 \u fv_tt A2 \u fv_tt C \u fv_tt D \u {{X}} \u dom E1 \u dom E2).
    +
      intros.      
      rewrite_alist (([(X0, bind_sub)] ++ E1) ++ E2).
      rewrite <- chooseS_open...
      rewrite <- chooseS_open...
      apply H0...
      rewrite_alist (nil ++[(X0, bind_sub)] ++ (E1 ++ (X, bind_sub) :: E2))...
      apply sub_weakening...
      constructor...
      apply suba_regular in H3.
      destruct_hypos...
      rewrite chooseS_open...
      rewrite chooseS_open...
      rewrite_alist ([(X0, bind_sub)] ++ E1 ++ (X, bind_sub) :: E2)...
      rewrite_alist (nil ++ X0 ~ bind_sub ++ (E1 ++ E2))...
      apply sub_weakening...
      constructor...
      rewrite_alist ([(X0, bind_sub)] ++ E1 ++ E2)...
   +
      intros.      
      rewrite_alist (([(X0, bind_sub)] ++ E1) ++ E2).
      rewrite <- chooseS_open2...
      rewrite <- chooseS_open2...
      apply H2...
      rewrite_alist (nil ++[(X0, bind_sub)] ++ (E1 ++ (X, bind_sub) :: E2))...
      apply sub_weakening...
      constructor...
      apply suba_regular in H3.
      destruct_hypos...
      rewrite chooseS_open2...
      rewrite chooseS_open2...
      rewrite_alist ([(X0, bind_sub)] ++ E1 ++ (X, bind_sub) :: E2)...
      rewrite_alist (nil ++ X0 ~ bind_sub ++ (E1 ++ E2))...
      apply sub_weakening...
      constructor...
      rewrite_alist ([(X0, bind_sub)] ++ E1 ++ E2)...
Qed. 


Lemma unfolding_lemma_version2 :
  forall E A B,
    sub E (typ_mu A) (typ_mu B) ->
    sub E (open_tt A (typ_mu A)) (open_tt B (typ_mu B)).
Proof with auto.
  intros.
  assert (Ht:=H).
  dependent destruction H.
  pick fresh X.
  assert (X \notin L) by eauto.
  apply H in H1...
  rewrite subst_tt_intro with (X:=X)...
  remember (subst_tt X (typ_mu A) (open_tt A X)).
  rewrite subst_tt_intro with (X:=X)...
  subst.
  rewrite_alist (nil ++  E) in Ht.
  apply sub_generalize_intensive with (A:=open_tt A X) (B:=open_tt B X) (X:=X) (m:=Pos) in Ht...
  simpl...
  rewrite <- subst_tt_intro...
  rewrite <- subst_tt_intro...
  apply H0...
Qed.

Lemma Sub_generalize_intensive : forall E A B,
    Sub E A B ->
    forall C D X m,
      Sub E C D ->
      forall n,
       Sub E (subst_tt X (UnfoldS n X C) C) (subst_tt X (UnfoldS n X D) D) ->
       Sub E (chooseS m X C D A) (chooseS m X D C B) ->
       Sub E (chooseD n m X C D A) (chooseD n m X D C B).
Proof with auto.
  intros.
  dependent induction H; simpl in *; eauto.
  -
    destruct m; unfold chooseD; eauto.
  -
    destruct m; simpl in *; subst; eauto; destruct (X == X0); simpl in *; eauto;subst.
    apply Sub_eq in H1...
    subst...
  -
    apply sub_regular in H2.
    destruct_hypos.
    destruct m; unfold chooseD; simpl in *; eauto.    
    constructor...
    apply subst_tt_wfs...
    constructor...
    apply subst_tt_wfs...
  -
    rewrite chooseD_arrow.
    rewrite chooseD_arrow.
    rewrite chooseS_arrow in H3.
    rewrite chooseS_arrow in H3.
    dependent destruction H3.
    constructor...
    eapply IHSub1 with (m:=flip m) in H2...
    destruct m; simpl in *; eauto.
    destruct m; simpl in *;  eauto.
  -
    rewrite chooseD_mu.
    rewrite chooseD_mu.
    rewrite chooseS_mu in H3.
    rewrite chooseS_mu in H3.
    dependent destruction H3.
    apply SA_rec with (L := L \u L0 \u fv_tt A1 \u fv_tt A2 \u fv_tt C \u fv_tt D \u {{X}} \u dom E).
    intros.
    assert (X0 \notin L) by eauto.
    assert (wf_env E /\ type C /\ type D) as q.
    {
      apply sub_regular in H1.
      destruct_hypos.
      apply wfs_type in H6.
      apply wfs_type in H7.
      split...
    }
    destruct_hypos.
    
    rewrite  chooseD_unfold...
    rewrite  chooseD_unfold...
    apply H0...
    rewrite_alist (nil ++ [(X0, bind_sub)] ++ E).
    apply Sub_weakening...
    constructor...
    rewrite_alist (nil ++ [(X0, bind_sub)] ++ E).
    apply Sub_weakening...
    constructor...
    rewrite <- chooseS_unfold...
    rewrite <- chooseS_unfold...
    apply H3...
Qed.


Lemma sub_subst_ver2 : forall E A B,
    Sub E A B -> forall X, 
    Sub E (subst_tt X A A) (subst_tt X B B) -> forall n, 
        Sub E (subst_tt X (UnfoldS n X A) A) (subst_tt X (UnfoldS n X B) B).
Proof with auto.
  intros.
  assert (E = nil ++ E) by eauto.
  induction n...
  rewrite H1 in *. 
  eapply Sub_generalize_intensive with (X:=X)  (A:=A) (B:=B) (m:=Pos) (n:=n) in H; simpl in *...
Qed.

Lemma soundness : forall E A B,
    sub E A B -> Sub E A B.
Proof with auto.
  intros.
  induction H; eauto.
  -
    constructor...
    apply soundness_wf; eauto.
  -
    apply SA_rec with (L := L \u fv_tt A1 \u fv_tt A2); intros.
    specialize_x_and_L X L.
    rewrite subst_tt_intro with (X:=X) in H2...
    remember (subst_tt X (open_tt A1 X) (open_tt A1 X)).
    rewrite subst_tt_intro with (X:=X) in H2...
    subst.
    destruct n.
    simpl...
    apply sub_subst_ver2 with (X:=X) (n:=n) in H0...
    rewrite <- unfoldS_unfoldT...
    rewrite <- unfoldS_unfoldT...
Qed.

