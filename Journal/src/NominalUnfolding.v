Require Import Metalib.Metatheory.
Require Import Program.Equality.
Require Export DoubleUnfolding.

Module Nominal.


Inductive typ : Set :=
| typ_top   : typ          
| typ_nat   : typ
| typ_bvar  : nat -> typ
| typ_fvar  : var -> typ
| typ_mu :    typ -> typ
| typ_arrow : typ -> typ -> typ
| typ_rcd : var -> typ -> typ
.



Coercion typ_bvar : nat >-> typ.
Coercion typ_fvar : atom >-> typ.

Fixpoint open_tt_rec (K : nat) (U : typ) (T : typ) {struct T} : typ :=
  match T with
  | typ_nat         => typ_nat      
  | typ_top         => typ_top              
  | typ_bvar J      => if K === J then U else (typ_bvar J)
  | typ_fvar X      => typ_fvar X 
  | typ_arrow T1 T2 => typ_arrow (open_tt_rec K U T1) (open_tt_rec K U T2)
  | typ_mu T        => typ_mu (open_tt_rec (S K) U T)
  | typ_rcd l T => typ_rcd l (open_tt_rec K U T)
  end.

(* T type U name *)
Definition open_tt T U := open_tt_rec 0 U T.

(** Types as locally closed pre-types *)

Inductive type : typ -> Prop :=
  | type_top :
      type typ_top
  | type_nat :
      type typ_nat      
  | type_var : forall X,
      type (typ_fvar X)
  | type_arrow : forall T1 T2,
      type T1 -> 
      type T2 -> 
      type (typ_arrow T1 T2)
  | type_rcd : forall l T,
      type T ->
      type (typ_rcd l T)
  | type_mu : forall L T,
      (forall X, X \notin L -> type (open_tt T (typ_fvar X))) ->
      type (typ_mu T)
.

Hint Constructors type : core.

Fixpoint subst_tt (Z : atom) (U : typ) (T : typ) {struct T} : typ :=
  match T with
  | typ_top => typ_top         
  | typ_nat => typ_nat
  | typ_bvar J => typ_bvar J
  | typ_fvar X => if X == Z then U else (typ_fvar X)
  | typ_arrow T1 T2 => typ_arrow (subst_tt Z U T1) (subst_tt Z U T2)
  | typ_mu T => typ_mu (subst_tt Z U T)
  | typ_rcd l T => typ_rcd l (subst_tt Z U T)
  end.

Fixpoint fv_tt (T : typ) {struct T} : atoms :=
  match T with
  | typ_top => {}
  | typ_nat => {}              
  | typ_bvar J => {}
  | typ_fvar X => {{ X }}
  | typ_arrow T1 T2 => (fv_tt T1) `union` (fv_tt T2)
  | typ_mu T => (fv_tt T)
  | typ_rcd l T => fv_tt T                     
  end.

Fixpoint fl_tt (T : typ) {struct T} : atoms :=
  match T with
  | typ_top => {}
  | typ_nat => {}             
  | typ_bvar J => {}
  | typ_fvar X => {}
  | typ_arrow T1 T2 => (fl_tt T1) `union` (fl_tt T2)
  | typ_mu T => (fl_tt T)
  | typ_rcd X T => {{ X }} `union` fl_tt T                       
  end.

Inductive binding : Set :=
  | bind_sub : binding.

Definition env := list (atom * binding).
Notation empty := (@nil (atom * binding)).


Inductive WF : env -> typ -> Prop :=
| WF_top : forall E, WF E typ_top                       
| WF_nat : forall E, WF E typ_nat
| WF_fvar : forall X E,
    binds X bind_sub E ->
    WF E (typ_fvar X)
| WF_arrow : forall E A B,
    WF E A ->
    WF E B ->
    WF E (typ_arrow A B)
| WF_rcd : forall E l T,
    WF E T ->
    WF E (typ_rcd l T)
| WF_rec : forall L E A,
      (forall  X, X \notin L -> 
        WF (X ~ bind_sub ++ E) (open_tt A X)) ->
      WF E (typ_mu A).


Inductive WFS : env -> typ -> Prop :=
| WFS_top : forall E, WFS E typ_top                         
| WFS_nat : forall E, WFS E typ_nat
| WFS_fvar : forall X E,
    binds X bind_sub E ->
    WFS E (typ_fvar X)
| WFS_arrow : forall E A B,
    WFS E A ->
    WFS E B ->
    WFS E (typ_arrow A B)
| WFS_rcd : forall E l T,
    WFS E T ->
    WFS E (typ_rcd l T)
| WFS_rec : forall L E A,
    (forall  X, X \notin L -> 
        WFS (X ~ bind_sub ++ E) (open_tt A (typ_rcd X (open_tt A X)))) ->
      (forall  X, X \notin L -> 
        WFS (X ~ bind_sub ++ E) (open_tt A X)) ->
      WFS E (typ_mu A).


Inductive wf_env : env -> Prop :=
  | wf_env_empty :
      wf_env empty
  | wf_env_sub : forall (E : env) (X : atom) ,
      wf_env E ->
      X \notin dom E ->
      wf_env (X ~ bind_sub ++ E)
.

     
Inductive Sub : env -> typ -> typ -> Prop :=
| S_nat: forall E,
    wf_env E ->
    Sub E typ_nat typ_nat
| S_fvar: forall E X,
    wf_env E ->
    WFS E (typ_fvar X) ->
    Sub E (typ_fvar X) (typ_fvar X)
| S_top : forall E A,
    wf_env E ->
    WFS E A -> 
    Sub E A typ_top      
| S_arrow: forall E A1 A2 B1 B2,
    Sub E B1 A1 ->
    Sub E A2 B2 ->
    Sub E (typ_arrow A1 A2) (typ_arrow B1 B2)
| S_rec: forall L A1 A2 E,
    (forall X,
        X \notin L -> WFS (X ~ bind_sub ++ E) (open_tt A1 X)) ->
    (forall X,
        X \notin L -> WFS (X ~ bind_sub ++ E) (open_tt A2 X)) ->
    (forall X,
        X \notin L ->
        Sub (X ~ bind_sub ++ E) (open_tt A1 (typ_rcd X (open_tt A1 X))) (open_tt A2 (typ_rcd X (open_tt A2 X)))) ->
    Sub E (typ_mu A1) (typ_mu A2)
| S_rcd : forall A B l E,
    Sub E A B ->
    Sub E (typ_rcd l A) (typ_rcd l B)
.


Inductive sub : env -> typ -> typ -> Prop :=
| Sa_nat: forall E,
    wf_env E ->
    sub E typ_nat typ_nat
| Sa_fvar: forall E X,
    wf_env E ->
    WF E (typ_fvar X) ->
    sub E (typ_fvar X) (typ_fvar X)
| Sa_top : forall E A,
    wf_env E ->
    WF E A -> 
    sub E A typ_top     
| Sa_arrow: forall E A1 A2 B1 B2,
    sub E B1 A1 ->
    sub E A2 B2 ->
    sub E (typ_arrow A1 A2) (typ_arrow B1 B2)
| Sa_rec: forall L A1 A2 E,
    (forall X,
        X \notin L ->
        sub (X ~ bind_sub ++ E) (open_tt A1 X) (open_tt A2 X)) ->
    (forall X,
        X \notin L ->
        sub (X ~ bind_sub ++ E) (open_tt A1 (open_tt A1 X)) (open_tt A2 (open_tt A2 X))) ->
    sub E (typ_mu A1) (typ_mu A2)
| Sa_rcd : forall A B l E,
    sub E A B ->
    sub E (typ_rcd l A) (typ_rcd l B)
.


Lemma subst_tt_intro_rec : forall X T2 U k,
  X `notin` fv_tt T2 ->
  open_tt_rec k U T2 = subst_tt X U (open_tt_rec k (typ_fvar X) T2).
Proof with congruence || auto.
  induction T2; intros U k Fr; simpl in *; f_equal...

    destruct (k === n)... simpl. destruct (X == X)...

    destruct (a == X)... contradict Fr; fsetdec.
Qed.

Lemma subst_tt_intro : forall X T2 U,
  X `notin` fv_tt T2 ->
  open_tt T2 U = subst_tt X U (open_tt T2 X).
Proof.
  intros.
  unfold open_tt.
  apply subst_tt_intro_rec...
  assumption.
Qed.

Lemma open_tt_rec_type_aux : forall T j V i U,
  i <> j ->
  open_tt_rec j V T = open_tt_rec i U (open_tt_rec j V T) ->
  T = open_tt_rec i U T.
Proof with congruence || eauto.
  induction T; intros j V i U Neq H; simpl in *; inversion H; f_equal...
    destruct (j === n)... destruct (i === n)...
Qed.

Lemma open_tt_rec_type : forall T U k,
  type T ->
  T = open_tt_rec k U T.
Proof with auto.
  intros T U k Htyp. revert k.
  induction Htyp; intros k; simpl; f_equal...

    unfold open_tt in *.
    pick fresh X.
    apply open_tt_rec_type_aux with (j:=0) (V:=X).
    auto.
    auto.
Qed.

Lemma subst_tt_fresh : forall Z U T,
   Z `notin` fv_tt T ->
   T = subst_tt Z U T.
Proof with auto.
  induction T; simpl; intro H; f_equal...

    destruct (a == Z)...
    contradict H; fsetdec.
Qed.
    
Lemma subst_tt_open_tt_rec : forall T1 T2 X P k,
  type P ->
  subst_tt X P (open_tt_rec k T2 T1) =
    open_tt_rec k (subst_tt X P T2) (subst_tt X P T1).
Proof with auto.
  intros T1 T2 X P k WP. revert k.
  induction T1; intros k; simpl; f_equal...

    destruct (k === n); subst...

    destruct (a == X); subst... apply open_tt_rec_type...
Qed.

Lemma subst_tt_open_tt : forall T1 T2 (X:atom) P,
  type P ->
  subst_tt X P (open_tt T1 T2) = open_tt (subst_tt X P T1) (subst_tt X P T2).
Proof with auto.
  intros.
  unfold open_tt.
  apply subst_tt_open_tt_rec...
Qed.

Lemma subst_tt_open_tt_var : forall (X Y:atom) P T,
  Y <> X ->
  type P ->
  open_tt (subst_tt X P T) Y = subst_tt X P (open_tt T Y).
Proof with congruence || auto.
  intros X Y P T Neq Wu.
  unfold open_tt.
  rewrite subst_tt_open_tt_rec...
  simpl.
  destruct (Y == X)...
Qed.

Lemma subst_tt_type : forall Z P T,
  type T ->
  type P ->
  type (subst_tt Z P T).
Proof with auto.
  intros Z P T HT HP.
  induction HT; simpl...
  destruct (X == Z)...

    pick fresh Y and apply type_mu...
    rewrite subst_tt_open_tt_var...
Qed.




Hint Constructors  WF WFS Sub sub wf_env: core.


Lemma WF_type: forall E A,
    WF E A ->
    type A.
Proof with auto.
  intros.
  induction H...
  apply type_mu with (L:=L)...
Qed.


Lemma WF_weakening: forall E1 E2 T E,
    WF (E1 ++ E2) T ->
    WF (E1 ++ E ++ E2) T.
Proof with auto.
  intros.
  generalize dependent E.
  dependent induction H;intros...
  -
    apply WF_rec with (L:=L)...
    intros.
    rewrite_alist (([(X, bind_sub)] ++ E1) ++ E ++ E2).
    apply H0...
Qed.

Lemma subst_tt_wf: forall A B E X,
    WF E A ->
    WF E B ->
    WF E (subst_tt X A B).
Proof with auto.
  intros.
  generalize dependent A.
  dependent induction H0;intros;simpl in *...
  -
    destruct (X0==X)...
  -
    apply WF_rec with (L:=L \u {{X}} \u fv_tt A0).
    intros.
    rewrite  subst_tt_open_tt_var...
    apply H0...
    rewrite_alist (nil ++ [(X0, bind_sub)] ++ E).
    apply WF_weakening...
    apply WF_type in H1...
Qed.


Lemma wfs_to_wf: forall E A,
    WFS E A ->
    WF E A.
Proof with auto.
  intros.
  induction H...
  apply WF_rec with (L:=L)...
Qed.

Lemma WFS_weakening: forall E1 E2 T E,
    WFS (E1 ++ E2) T ->
    WFS (E1 ++ E ++ E2) T.
Proof with auto.
  intros.
  generalize dependent E.
  dependent induction H;intros...
  -
    apply WFS_rec with (L:=L);intros...
    +
      rewrite_alist (([(X, bind_sub)] ++ E1) ++ E ++ E2).
      apply H0...
    +
      rewrite_alist (([(X, bind_sub)] ++ E1) ++ E ++ E2).
      apply H2...
Qed.

Lemma WFS_type: forall E A,
    WFS E A ->
    type A.
Proof with auto.
  intros.
  induction H...
  apply type_mu with (L:=L)...
Qed.

Lemma rcd_transform2:forall A C (X Y :atom),
    X <> Y -> type C ->
    (open_tt (subst_tt X C A) (typ_rcd Y (open_tt (subst_tt X C A) Y))) = (subst_tt X C (open_tt A (typ_rcd Y (open_tt A Y)))).
Proof with auto.
  intros.
  rewrite subst_tt_open_tt...
  f_equal...
  simpl...
  f_equal...
  rewrite subst_tt_open_tt_var...
Qed.  

Lemma subst_tt_wfs: forall A B E X,
    WFS E A ->
    WFS E B ->
    WFS E (subst_tt X A B).
Proof with auto.
  intros.
  generalize dependent A.
  dependent induction H0;intros;simpl in *...
  -
    destruct (X0==X)...
  -
    apply WFS_rec with (L:=L \u {{X}} \u fv_tt A0);intros...
    +
      rewrite rcd_transform2...
      apply H0...
      rewrite_alist (nil ++ [(X0, bind_sub)] ++ E).
      apply WFS_weakening...
      apply WFS_type in H3...
    +
      rewrite  subst_tt_open_tt_var...
      apply H2...
      rewrite_alist (nil ++ [(X0, bind_sub)] ++ E).
      apply WFS_weakening...
      apply WFS_type in H3...
Qed.

Lemma wf_to_wfs: forall E A,
    WF E A ->
    WFS E A.
Proof with auto.
  intros.
  induction H...
  apply WFS_rec with (L:=L \u fv_tt A)...
  intros.
  rewrite subst_tt_intro with (X:=X)...
  apply subst_tt_wfs...
Qed.


Fixpoint subst_label (Z : atom)  (T : typ) {struct T} : typ :=
  match T with
  | typ_top => typ_top            
  | typ_nat => typ_nat
  | typ_bvar J => typ_bvar J
  | typ_fvar X =>  (typ_fvar X)
  | typ_arrow T1 T2 => typ_arrow (subst_label Z  T1) (subst_label Z  T2)
  | typ_mu T => typ_mu (subst_label Z  T)
  | typ_rcd l T => if (l==Z) then (typ_fvar Z) else typ_rcd l (subst_label Z  T)
  end.

Lemma subst_label_open_tt_rec : forall T1 T2 X  k,

  subst_label X  (open_tt_rec k T2 T1) =
    open_tt_rec k (subst_label X  T2) (subst_label X  T1).
Proof with auto.
  intros T1. 
  induction T1; intros ; simpl in *; f_equal...

    destruct (k === n); subst...

    destruct (a == X); subst...
    simpl.
    f_equal...    
Qed.

Lemma subst_label_open_tt : forall T1 T2 (X:atom),
  subst_label X  (open_tt T1 T2) = open_tt (subst_label X  T1) (subst_label X  T2).
Proof with auto.
  intros.
  unfold open_tt.
  apply subst_label_open_tt_rec...
Qed.

Lemma subst_label_open_tt_var : forall T1 (Y X:atom),
  subst_label X  (open_tt T1 Y) = open_tt (subst_label X  T1) Y.
Proof with auto.
  intros.
  unfold open_tt.
  apply subst_label_open_tt_rec...
Qed.

Lemma subst_label_wfs: forall E1 E2 A X,
    WF (E1++ [(X, bind_sub)] ++ E2) A ->
    WF (E1 ++ [(X, bind_sub)] ++ E2) (subst_label X A).
Proof with auto.
  intros.
  dependent induction H; simpl in *...
  -
    destruct (l==X)...
  -
    apply WF_rec with (L:=L \u {{X}});intros...
    rewrite <- subst_label_open_tt_var ...
    rewrite_alist (([(X0, bind_sub)] ++ E1) ++ (X, bind_sub) :: E2).
    apply H0...
Qed.    


Lemma label_transform2: forall A X X0,
    X <> X0 ->
    (subst_label X (open_tt A (typ_rcd X0 (open_tt A X0)))) =
(open_tt (subst_label X A) (typ_rcd X0 (open_tt (subst_label X A) X0))).
Proof with auto.
  intros.
  rewrite subst_label_open_tt...
  f_equal...
  simpl...
  destruct (X0==X)...
  destruct H...
  f_equal...
  rewrite subst_label_open_tt...
Qed.


Lemma sub_regular : forall  E A B,
    sub E A B ->
    WF E A /\ WF E B /\ wf_env E.
Proof with auto.
  intros.
  dependent induction H;try solve [destruct_hypos;repeat split;auto]...  
  split.
  apply WF_rec with (L:=L)...
  intros.
  apply H0 in H3.
  destruct_hypos...
  split.
  apply WF_rec with (L:=L)...
  intros.
  apply H0 in H3.
  destruct_hypos...
  pick fresh X.
  specialize_x_and_L X L.
  destruct_hypos.
  inversion H4...
Qed.

Lemma Sub_regular : forall  E A B,
    Sub E A B ->
    WFS E A /\ WFS E B /\ wf_env E.
Proof with auto.
  intros.
  dependent induction H;try solve [destruct_hypos;repeat split;auto]...  
  split.
  apply WFS_rec with (L:=L);intros...
  eapply H2...
  split.
  apply WFS_rec with (L:=L);intros...
  eapply H2...
  pick fresh X.
  specialize_x_and_L X L.
  destruct_hypos.
  inversion H4...
Qed.  
  
  
Lemma open_twice_to_one: forall E1 E2 A B X,
    sub (E1++ [(X, bind_sub)] ++ E2) A B ->
    sub (E1++ [(X, bind_sub)] ++ E2) (subst_label X A) (subst_label X B).
Proof with eauto using subst_label_wfs. 
  intros.
  dependent induction H;try solve [simpl in *;auto]...
  -
    simpl in *.
    apply Sa_rec with (L:=L \u fv_tt A1 \u fv_tt A2 \u {{X}});intros.
    rewrite <- subst_label_open_tt_var...
    rewrite <- subst_label_open_tt_var...
    rewrite_alist (([(X0, bind_sub)] ++ E1) ++ (X, bind_sub) :: E2).
    apply H0...
    rewrite <- subst_label_open_tt_var...
    rewrite <- subst_label_open_tt_var...
    rewrite <- subst_label_open_tt...
    rewrite <- subst_label_open_tt...
    rewrite_alist (([(X0, bind_sub)] ++ E1) ++ (X, bind_sub) :: E2).
    apply H2...
  -
    simpl in *.
    destruct (l==X)...
    constructor...
    apply sub_regular in H.
    destruct_hypos...
Qed.


  


Lemma label_transform: forall A X B ,
    X \notin fl_tt A ->
    subst_label X (open_tt A (typ_rcd X B) ) = open_tt A X .
Proof with auto.
  intro A.
  unfold open_tt.
  generalize 0.
  induction A;intros;simpl in *;try solve [f_equal;auto]...
  -
    destruct (n0==n)...
    simpl...
    destruct (X==X)...
    destruct n1...
  -
    destruct (a==X)...
    subst.
    apply notin_union in H.
    destruct H.
    apply notin_singleton_1 in H.
    destruct H...
    f_equal...
Qed.

Lemma WF_subst_rcd: forall E A,
    WF E A ->
    forall X B,
      type B ->
    WF E (subst_tt X (typ_rcd X B) A) ->
    WF E (subst_tt X B A).
Proof with auto.
  intros E A H.
  induction H;intros;simpl in *...
  -
    destruct (X==X0)...
    inversion H1...
  -
    dependent destruction H2...
  -
    dependent destruction H1...
  -
    dependent destruction H2...
    apply WF_rec with (L:=L \u L0 \u fv_tt A \u fv_tt B \u {{X}}).
    intros.
    rewrite subst_tt_open_tt_var...
    apply H0...
    rewrite <- subst_tt_open_tt_var...
    apply H2...
Qed.    

Lemma sub_subst_rcd: forall E A B,
    sub E A B ->
    forall X C D,
      sub E (subst_tt X (typ_rcd X C) A) (subst_tt X (typ_rcd X D) B) ->
      type C -> type D ->
      sub E (subst_tt X C A) (subst_tt X D B).
Proof with auto.
  intros E A B H.
  induction H;intros...
  -
    simpl in *.
    destruct (X==X0)...
    dependent destruction H1...
  -
    simpl in *.
    constructor...
    apply sub_regular in H1.
    destruct_hypos.
    apply WF_subst_rcd...
  -
    simpl in *...
    dependent destruction H1...
  -
    simpl in *.
    dependent destruction H3...
    apply Sa_rec with (L:=L \u L0 \u {{X}} \u fv_tt A1 \u fv_tt A2);intros.
    +
      rewrite subst_tt_open_tt_var...
      rewrite subst_tt_open_tt_var...
      apply H0...
      rewrite <- subst_tt_open_tt_var...
      rewrite <- subst_tt_open_tt_var...
      apply H3...
    +
      rewrite subst_tt_open_tt_var...
      rewrite subst_tt_open_tt_var...
      rewrite <- subst_tt_open_tt...
      rewrite <- subst_tt_open_tt...
      apply H2...
      rewrite  subst_tt_open_tt...
      rewrite <- subst_tt_open_tt_var...
      rewrite  subst_tt_open_tt...
      rewrite <- subst_tt_open_tt_var...
      apply H4...
  -
    simpl in *...
    dependent destruction H0...
Qed.



Lemma rcd_transform: forall A B (X Y :atom),
    X <> Y -> type B -> type (open_tt A Y) ->
    subst_tt X (typ_rcd X B) (open_tt A (typ_rcd Y (open_tt A Y))) =
  open_tt (subst_tt X (typ_rcd X B) A) (typ_rcd Y (open_tt (subst_tt X (typ_rcd X B) A) Y)).
Proof with auto.
  intros.
  rewrite subst_tt_open_tt...
  f_equal...
  simpl...
  f_equal...
  rewrite subst_tt_open_tt...
  f_equal...
  rewrite <- subst_tt_fresh...
Qed.

Lemma Sub_subst_rcd: forall E A B,
    Sub E A B ->
    forall X C D,
      Sub E (subst_tt X C A) (subst_tt X D B) ->
      WFS E C -> WFS E D ->
      Sub E (subst_tt X (typ_rcd X C) A) (subst_tt X (typ_rcd X D) B).
Proof with auto.
  intros E A B H.
  induction H;intros...
  -
    simpl in *.
    destruct (X==X0)...
  -
    simpl in *.
    constructor...
    apply subst_tt_wfs...
  -
    simpl in *...
    dependent destruction H1...
  -
    simpl in *.
    dependent destruction H3...
    apply S_rec with (L:=L \u L0 \u {{X}} \u fv_tt A1 \u fv_tt A2);intros.
    +
      rewrite subst_tt_open_tt_var...
      apply subst_tt_wfs...
      constructor.
      rewrite_alist (nil ++ [(X0, bind_sub)] ++ E).
      apply WFS_weakening...
      apply H...
      constructor.
      apply WFS_type in H6...
    +
      rewrite subst_tt_open_tt_var...
      apply subst_tt_wfs...
      constructor.
      rewrite_alist (nil ++ [(X0, bind_sub)] ++ E).
      apply WFS_weakening...
      apply H0...
      constructor.
      apply WFS_type in H7...
    +
      assert (type C).
      apply WFS_type in H6...
      assert (type D).
      apply WFS_type in H7...
      rewrite <- rcd_transform...
      rewrite <- rcd_transform...
      apply H2...
      rewrite <- rcd_transform2...
      rewrite <- rcd_transform2...
      apply H5...
      rewrite_alist (nil ++ [(X0, bind_sub)] ++ E).
      apply WFS_weakening...
      rewrite_alist (nil ++ [(X0, bind_sub)] ++ E).
      apply WFS_weakening...
      specialize_x_and_L X0 L.
      apply WFS_type in H0...
      specialize_x_and_L X0 L.
      apply WFS_type in H...
  -
    simpl in *...
    dependent destruction H0...
Qed.

Lemma sub_to_Sub: forall E A B,
    sub E A B ->
    Sub E A B.
Proof with auto.
  intros.
  induction H;try solve [constructor;auto;apply wf_to_wfs;auto]...
  apply S_rec with (L:=L \u fv_tt A1 \u fv_tt A2);intros...
  -
    specialize_x_and_L X L.
    apply Sub_regular in H0.
    destruct_hypos...
  -
    specialize_x_and_L X L.
    apply Sub_regular in H0.
    destruct_hypos...
  -
    rewrite subst_tt_intro with (X:=X)...
    remember (subst_tt X (typ_rcd X (open_tt A1 X)) (open_tt A1 X)).
    rewrite subst_tt_intro with (X:=X)...
    subst.
    apply Sub_subst_rcd...
    rewrite <- subst_tt_intro...
    rewrite <- subst_tt_intro...
    specialize_x_and_L X L.
    apply Sub_regular in H0.
    destruct_hypos...
    specialize_x_and_L X L.
    apply Sub_regular in H0.
    destruct_hypos...
Qed.  

Lemma open_twice_to_once: forall E1 E2 X A1 A2,
     sub (E1 ++ [(X, bind_sub)] ++ E2) (open_tt A1 (typ_rcd X (open_tt A1 X)))
         (open_tt A2 (typ_rcd X (open_tt A2 X))) ->
     X \notin fl_tt A1 \u fl_tt A2 ->
     sub (E1 ++ [(X, bind_sub)] ++ E2) (open_tt A1 X) (open_tt A2 X).
Proof with auto.
  intros.
  apply open_twice_to_one in H...
  rewrite label_transform in H...
  rewrite label_transform in H...
Qed.

Lemma Sub_to_sub: forall E A B,
    Sub E A B ->
    sub E A B.
Proof with auto.
  intros.
  induction H;try solve [constructor;auto;apply wfs_to_wf;auto]...
  apply Sa_rec with (L:=L \u fl_tt A1 \u fl_tt A2 \u fv_tt A1 \u fv_tt A2);intros...
  -
    specialize_x_and_L X L.
    rewrite_alist (nil ++ [(X, bind_sub)] ++ E) in H2.
    apply open_twice_to_once in H2...
  -
    assert (Hq:=H2).
    specialize_x_and_L X L.
    rewrite_alist (nil ++ [(X, bind_sub)] ++ E) in H2.
    apply open_twice_to_once in H2...
    apply sub_subst_rcd with (X:=X) (C:=open_tt A1 X) (D:=open_tt A2 X) in H2...
    rewrite <- subst_tt_intro in H2...
    rewrite <- subst_tt_intro in H2...
    rewrite <- subst_tt_intro...
    rewrite <- subst_tt_intro...
    apply WFS_type in H...
    apply WFS_type in H0...
Qed.



Ltac gather_atoms ::=
  let A := gather_atoms_with (fun x : atoms => x) in
  let B := gather_atoms_with (fun x : atom => singleton x) in
  let C := gather_atoms_with (fun x : typ => fv_tt x) in
  let D := gather_atoms_with (fun x : typ => fl_tt x) in
  let F := gather_atoms_with (fun x : env => dom x) in
  constr:(A `union` B `union` C \u D \u F).

Lemma label_transform3: forall A (X X0 Y : atom),
    X <> X0 ->
    (subst_tt X Y (open_tt A (typ_rcd X0 (open_tt A X0)))) =
(open_tt (subst_tt X Y A) (typ_rcd X0 (open_tt (subst_tt X Y A) X0))).
Proof with auto.
  intros.
  rewrite  subst_tt_open_tt...
  f_equal...
  simpl.
  f_equal...
  rewrite  subst_tt_open_tt_var...
Qed.

Lemma WFS_replacing: forall E1 E2 T X Y,
    WFS (E1++ X ~ bind_sub ++E2) T ->
    X <> Y ->
    WFS (E1++ Y ~ bind_sub ++E2) (subst_tt X Y T).
Proof with auto.
  intros.
  generalize dependent Y.
  dependent induction H;intros;simpl;try solve [rewrite_alist (E1 ++ Y ~ bind_sub ++ E2);constructor;auto]...
  -
    destruct (X0==X)...
    constructor.
    analyze_binds H.
  -
    apply WFS_rec with (L:=L \u {{X}});intros.
    rewrite <- label_transform3...
    rewrite_alist (([(X0, bind_sub)] ++ E1) ++ Y ~ bind_sub ++ E2).
    apply H0...
    rewrite  subst_tt_open_tt_var...
    rewrite_alist (([(X0, bind_sub)] ++ E1) ++ Y ~ bind_sub ++ E2).
    apply H2...
Qed.

Lemma WFS_replacing_var: forall E T X Y,
    WFS (X ~ bind_sub ++E) (open_tt T X) ->
    X \notin fv_tt T \u {{Y}} ->
    WFS (Y ~ bind_sub ++E) (open_tt T Y).
Proof with auto.
  intros.
  rewrite_alist (nil ++ [(Y, bind_sub)] ++ E).
  rewrite subst_tt_intro with (X:=X)...
  apply WFS_replacing...
Qed.

Lemma Sub_replacing: forall E1 E2 A B X Y,
    Sub (E1++ X ~ bind_sub ++E2) A B ->
    X <> Y ->
    wf_env (E1 ++ Y ~ bind_sub ++ E2) ->
    Sub (E1++ Y ~ bind_sub ++E2) (subst_tt X Y A) (subst_tt X Y B).
Proof with auto.
  intros.
  generalize dependent Y.
  dependent induction H;intros;simpl;try solve [rewrite_alist (E1 ++ [(Y, bind_sub)] ++ E2);constructor;auto;apply  WFS_replacing;auto]...
  -
    destruct (X0==X)...
    constructor...
    constructor...
    dependent destruction H0.
    analyze_binds H0.
  -
    apply S_rec with (L:=L  \u {{X}} \u dom (E1 ++ [(Y, bind_sub)] ++ E2) );intros...
    rewrite  subst_tt_open_tt_var...
    rewrite_alist (([(X0, bind_sub)] ++ E1) ++ Y ~ bind_sub ++ E2).
    apply WFS_replacing...
    rewrite_alist ([(X0, bind_sub)] ++ E1 ++ [(X, bind_sub)] ++ E2)...
    rewrite  subst_tt_open_tt_var...
    rewrite_alist (([(X0, bind_sub)] ++ E1) ++ Y ~ bind_sub ++ E2).
    apply WFS_replacing...
    rewrite_alist ([(X0, bind_sub)] ++ E1 ++ [(X, bind_sub)] ++ E2)...
    rewrite <- label_transform3...
    rewrite <- label_transform3...
    rewrite_alist (([(X0, bind_sub)] ++ E1) ++ Y ~ bind_sub ++ E2).
    apply H2...
    rewrite_alist ([(X0, bind_sub)] ++ E1 ++ [(Y, bind_sub)] ++ E2).
    constructor...
Qed.

Fixpoint subst_tl (Z : atom) (U : atom) (T : typ) {struct T} : typ :=
  match T with
  | typ_top => typ_top             
  | typ_nat => typ_nat
  | typ_bvar J => typ_bvar J
  | typ_fvar X => typ_fvar X
  | typ_arrow T1 T2 => typ_arrow (subst_tl Z U T1) (subst_tl Z U T2)
  | typ_mu T => typ_mu (subst_tl Z U T)
  | typ_rcd l T => if (l==Z) then typ_rcd U (subst_tl Z U T) else typ_rcd l (subst_tl Z U T)
  end.

Lemma label_transform1: forall (X Y:atom) A,
    X \notin fv_tt A ->
    (subst_tt X Y (open_tt A (typ_rcd X (open_tt A X)))) =
    (open_tt A (typ_rcd X (open_tt A Y))).
Proof with auto.
  intros.
  rewrite subst_tt_open_tt...
  simpl...
  rewrite <- subst_tt_intro...
  f_equal...
  rewrite <- subst_tt_fresh...
Qed.

Lemma subst_tl_open_tt_rec : forall Z  A (X Y : atom) k,
    subst_tl X Y (open_tt_rec k A Z) = open_tt_rec k (subst_tl X Y A) (subst_tl X Y Z).
Proof with auto.
  intros Z.
  induction Z;intros ; simpl in *; f_equal...
  -
    destruct (k==n)...
  -
    destruct (a==X);subst;simpl...
    f_equal...
    f_equal...
Qed.

Lemma subst_tl_open_tt : forall A Z (X Y : atom),
    subst_tl X Y (open_tt A Z) = open_tt (subst_tl X Y A) (subst_tl X Y Z).
Proof with auto.
  intros.
  unfold open_tt.
  apply subst_tl_open_tt_rec...
Qed.

Lemma label_transform4: forall A (X X0 Y : atom),
    X <> X0 ->
    (subst_tl X Y (open_tt A (typ_rcd X0 (open_tt A X0)))) =
(open_tt (subst_tl X Y A) (typ_rcd X0 (open_tt (subst_tl X Y A) X0))).
Proof with auto.
  intros.
  rewrite  subst_tl_open_tt...
  f_equal...
  simpl.
  destruct (X0==X);subst...
  destruct H...
  f_equal...
  rewrite subst_tl_open_tt...
Qed.

Lemma subst_tl_open_tt_var : forall A (X Y Z: atom),
    subst_tl X Y (open_tt A Z) = open_tt (subst_tl X Y A) Z.
Proof with auto.
  intros.
  unfold open_tt.
  apply subst_tl_open_tt_rec...
Qed.  
  
Lemma WFS_replacing2: forall E T X Y,
    WFS E T ->
    X <> Y ->
    WFS E (subst_tl X Y T).
Proof with auto.
  intros.
  generalize dependent Y.
  dependent induction H;intros;simpl;try solve [constructor;auto]...
  -
    destruct (l==X);subst...
  -
    apply WFS_rec with (L:=L \u {{X}});intros.
    rewrite <- label_transform4...
    rewrite <- subst_tl_open_tt_var...
Qed.

Lemma Sub_replacing2: forall E A B X Y,
    Sub E A B ->
    X <> Y ->
    Sub E (subst_tl X Y A) (subst_tl X Y B).
Proof with eauto using WFS_replacing2.
  intros.
  generalize dependent Y.
  dependent induction H;intros;simpl;try solve [constructor;auto]...
  -
    apply S_rec with (L:=L  \u {{X}} \u dom E );intros...
    rewrite <- subst_tl_open_tt_var...
    rewrite <- subst_tl_open_tt_var...
    rewrite <- label_transform4...
    rewrite <- label_transform4...
  -
    destruct (l==X);subst...
Qed.

Lemma subst_tl_fresh: forall A X Y,
    X `notin` fl_tt A ->
    subst_tl X Y A = A.
Proof with auto.
  induction A;intros;simpl in *;try solve [f_equal;auto]...
  destruct (a==X);subst...
  apply notin_union in H.
  destruct H.
  apply notin_singleton_1 in H...
  destruct H...
  f_equal...
Qed.

Lemma notin_fl_tt_open : forall X U T,
    X `notin` fl_tt T ->
    X \notin fl_tt U ->
    X `notin` fl_tt (open_tt T U).
Proof with auto.
  intros.
  unfold open_tt.
  unfold open_tt_rec.
  generalize 0.
  induction T;simpl in *;intros...
  destruct (n0==n)...
Qed.

Lemma label_transform5: forall (X Y Z:atom) A,
    X \notin fl_tt A ->
    (subst_tl X Y (open_tt A (typ_rcd X (open_tt A Z)))) =
    (open_tt A (typ_rcd Y (open_tt A Z))).
Proof with auto.
  intros.
  rewrite subst_tl_open_tt...
  simpl...
  destruct (X==X)...
  f_equal...
  apply subst_tl_fresh...
  f_equal...
  apply subst_tl_fresh...
  apply notin_fl_tt_open...
  destruct n...
Qed.

Lemma Sub_replacing_open: forall E1 E2 A B X Y,
    Sub (E1 ++X ~ bind_sub ++E2) (open_tt A (typ_rcd X (open_tt A X))) (open_tt B (typ_rcd X (open_tt B X)))  ->
    Y \notin {{X}} \u fv_tt A \u fv_tt B ->
    X \notin fv_tt A \u fv_tt B \u fl_tt A \u fl_tt B ->
    wf_env (E1 ++ [(Y, bind_sub)] ++ E2) ->
    Sub (E1++ Y ~ bind_sub ++E2) (open_tt A (typ_rcd Y (open_tt A Y))) (open_tt B (typ_rcd Y (open_tt B Y))).
Proof with auto.
  intros.
  apply Sub_replacing with (Y:=Y) in H...
  rewrite label_transform1 in H...
  rewrite label_transform1 in H...
  apply Sub_replacing2 with (X:=X) (Y:=Y) in H...
  rewrite label_transform5 in H...
  rewrite label_transform5 in H...
Qed.  



Lemma sub_refl : forall E A ,
    wf_env E -> WFS E A -> Sub E A A.
Proof with auto.
  intros.
  induction H0...
  apply S_rec with (L:=L \u dom E);intros...
Qed.

Ltac solve_by_inv H H1 := dependent destruction H;dependent destruction H1;auto.
Ltac get_well_form :=
    repeat match goal with
           | [ H : Sub _ _ _ |- _ ] => apply Sub_regular in H;destruct_hypos
           end.

Lemma trans_aux: forall B E,
    WFS E B -> forall A C,
    Sub E A B -> Sub E B C -> Sub E A C.
Proof with auto.
  intros B E H.
  dependent induction H;intros;try solve [solve_by_inv H0 H|solve_by_inv H H0|solve_by_inv H0 H2]...
  -
    dependent destruction H1...
    dependent destruction H2...
    constructor...
    get_well_form...
  -
    dependent destruction H1.
    constructor...
    get_well_form...
    dependent destruction H0...
  -
    dependent destruction H3.
    dependent destruction H6...
    constructor...
    apply WFS_rec with (L:=L0 \u L)...
    intros...
    specialize_x_and_L X L0.
    get_well_form...
    apply S_rec with (L:=L \u L0 \u L1)...
Qed.

Lemma Transitivity: forall B E A C,
    Sub E A B -> Sub E B C -> Sub E A C.
Proof with auto.
  intros.
  apply trans_aux with (B:=B)...
  get_well_form...
Qed.

Definition choose (m : Mode)  (C : typ) (D : typ) :=
  match m with
  | Pos => C
  | Neg => D
  end.


Lemma choose_flip: forall m A B ,
    choose m A B = choose (flip m) B A .
Proof with auto.
  intros.
  destruct m...
Qed.

Lemma WFS_permutation : forall A B C D  T ,
    WFS ( A ++ B ++ C ++ D ) T ->
    WFS ( A ++ C ++ B ++ D) T.
Proof with auto.
  intros.
  dependent induction H...
  -
    constructor...
    analyze_binds H...
  -
    apply WFS_rec with (L:=L);intros;
      rewrite_alist (([(X, bind_sub)]  ++ A) ++ C ++ B ++ D)...
Qed.

Lemma Sub_permutation: forall A B C D S T,
    Sub (A ++ B ++ C ++ D) S T ->
    wf_env (A ++ C ++ B ++ D) ->
    Sub (A ++ C ++ B ++ D) S T.
Proof with auto using WFS_permutation.
   intros.
   dependent induction H...
   -
     apply S_rec with (L:=L \u dom (A ++ B++C ++D) );intros;
     rewrite_alist (([(X, bind_sub)]  ++ A) ++ C ++ B ++ D)...
     apply WFS_permutation...
     rewrite_alist ([(X, bind_sub)]  ++ A ++ B ++ C ++ D)...
     apply WFS_permutation...
     rewrite_alist ([(X, bind_sub)]  ++ A ++ B ++ C ++ D)...
     apply H2...
     rewrite_alist ([(X, bind_sub)]  ++ A ++ C ++ B ++ D)...
Qed.

Lemma Sub_subst_rcd_dismiss: forall E E1 A B X C D,
    X `notin` fl_tt A \u fl_tt B ->
    Sub (E1++[(X, bind_sub)] ++ E) (subst_tt X (typ_rcd X C) A)
        (subst_tt X (typ_rcd X D) B) ->
    type C -> type D ->
    WFS (E1 ++ [(X, bind_sub)] ++ E) A ->
    WFS (E1 ++ [(X, bind_sub)] ++ E) B ->
    Sub (E1++[(X, bind_sub)] ++ E) A B.
Proof with auto.
  intros.
  dependent induction H0;try solve [simpl in *;auto]...
  -
    induction A;try solve [simpl in *;inversion x0|simpl in *;destruct (a==X);inversion x0]...
    induction B;try solve [simpl in *;inversion x|simpl in *;destruct (a==X);inversion x]...
  -
    induction A;try solve [simpl in *;inversion x0|simpl in *;destruct (a==X);inversion x0]...
    induction B;try solve [simpl in *;inversion x|simpl in *;destruct (a==X);inversion x]...
    simpl in *.
    destruct (a==X);destruct (a0==X);try solve [inversion x0|inversion x]...
    rewrite <-x0.
    rewrite <-x.
    apply sub_refl...
  -
    induction B;try solve [simpl in *;inversion x|simpl in *;destruct (a==X);inversion x]...
  -
    induction A;try solve [simpl in *;inversion x0|simpl in *;destruct (a==X);inversion x0]...
    induction B;try solve [simpl in *;inversion x|simpl in *;destruct (a==X);inversion x]...
    clear IHB1 IHB2 IHA1 IHA2.
    simpl in *.
    inversion x0.
    inversion x.
    dependent destruction H3.
    dependent destruction H4.
    constructor...
    apply IHSub1 with (C:=D) (D:=C)...
    apply IHSub2 with (C:=C) (D:=D)...
  -
    induction A;try solve [simpl in *;inversion x0|simpl in *;destruct (a==X);inversion x0]...
    induction B;try solve [simpl in *;inversion x|simpl in *;destruct (a==X);inversion x]...
    clear IHA IHB.
    simpl in *.
    inversion x0.
    inversion x.
    dependent destruction H6.
    dependent destruction H8.
    apply S_rec with (L:=L \u L0 \u L1 \u fv_tt A \u fv_tt B \u {{X}} \u fv_tt C
                     \u fv_tt D \u dom (E1 ++(X~ bind_sub)++ E));intros...
    rewrite_alist  (([(X0, bind_sub)] ++ E1) ++ (X, bind_sub) :: E).
    apply H2 with (X0:=X0) (C:=C) (D:=D)...
    *
      apply notin_union...
      split;apply notin_fl_tt_open;simpl.
      auto.
      apply notin_union.
      split...
      apply notin_fl_tt_open...
      auto.
      apply notin_union.
      split...
      apply notin_fl_tt_open... 
    *
      subst.
      rewrite  subst_tt_open_tt...
      f_equal...
      simpl...
      f_equal...
      rewrite  subst_tt_open_tt_var...
    *
      subst.
      rewrite  subst_tt_open_tt...
      f_equal...
      simpl...
      f_equal...
      rewrite  subst_tt_open_tt_var...
    *      
      apply H6...
    *
      apply H8...
  -
    induction A;try solve [simpl in *;inversion x0|simpl in *;destruct (a==X);inversion x0];
    induction B;try solve [simpl in *;inversion x|simpl in *;destruct (a==X);inversion x]...
    +
      simpl in *.
      destruct (a==X);destruct (a0==X);try solve [inversion x|inversion x0]...
      inversion x.
      inversion x0;subst.
      apply sub_refl...
      get_well_form...
    +
      clear IHB.
      simpl in *.
      destruct (a==X);subst;try solve [inversion x0]...
      inversion x0.
      inversion x;subst...
      apply notin_union in H.
      destruct H.
      apply notin_union in H5.
      destruct H5.
      apply test_solve_notin_7 in H5...
      destruct H5.
    +
      clear IHA.
      simpl in *.
      destruct (a0==X);subst;try solve [inversion x]...
      inversion x0.
      inversion x;subst...
      apply notin_union in H.
      destruct H.
      apply notin_union in H.
      destruct H.
      apply test_solve_notin_7 in H...
      destruct H.
    +
      clear IHA IHB.
      simpl in *.
      inversion x0.
      inversion x;subst...
      constructor...
      apply IHSub with (C0:=C) (D0:=D)...
      dependent destruction H3...
      dependent destruction H4...
Qed.

  
Lemma Sub_twice_to_one: forall E E1 A B X,
    X `notin` fl_tt A \u fl_tt B \u fv_tt A \u fv_tt B ->
    Sub (E1++[(X, bind_sub)] ++ E) (open_tt A (typ_rcd X (open_tt A X)))
        (open_tt B (typ_rcd X (open_tt B X))) ->
    WFS (E1 ++ [(X, bind_sub)] ++ E) (open_tt A X) ->
    WFS (E1 ++ [(X, bind_sub)] ++ E) (open_tt B X) ->
    Sub (E1++[(X, bind_sub)] ++ E) (open_tt A X) (open_tt B X).
Proof with auto.
  intros.
  rewrite subst_tt_intro with (X:=X) in H0...
  remember (subst_tt X (typ_rcd X (open_tt A X)) (open_tt A X)).
  rewrite subst_tt_intro with (X:=X) in H0...
  subst.
  apply Sub_subst_rcd_dismiss in H0... 
  apply notin_union.
  split.
  apply notin_fl_tt_open...
  apply notin_fl_tt_open...
  apply WFS_type in H1...
  apply WFS_type in H2...
Qed.    


Lemma Sub_weakening: forall E E1 E2 A B,
    Sub (E1++E2) A B ->
    wf_env (E1 ++ E ++ E2) ->
    Sub (E1++E++E2) A B.
Proof with eauto using WFS_weakening.
  intros.
  generalize dependent E.
  dependent induction H;intros...
  apply S_rec with (L:=L \u dom (E1 ++ E ++ E2));intros...
  rewrite_alist (([(X, bind_sub)] ++ E1) ++ E ++ E2).
  apply WFS_weakening...
  rewrite_alist ([(X, bind_sub)] ++ E1 ++ E2)...
  rewrite_alist (([(X, bind_sub)] ++ E1) ++ E ++ E2).
  apply WFS_weakening...
  rewrite_alist ([(X, bind_sub)] ++ E1 ++ E2)...
  rewrite_alist (([(X, bind_sub)] ++ E1) ++ E ++ E2).
  apply H2...
  rewrite_alist ([(X, bind_sub)] ++ E1 ++ E ++ E2)...
Qed.

Lemma subst_tt_equiv: forall E A B,
    Sub E A B -> forall C D X,
    Sub E C D -> Sub E D C ->
    Sub E (subst_tt X (typ_rcd X C) A) (subst_tt X (typ_rcd X D) B).
Proof with auto.
  intros E A B H.
  induction H;intros;destruct_hypos;simpl in *;try solve [constructor]...
  -
    destruct (X==X0)...
  -
    constructor...
    get_well_form.
    apply subst_tt_wfs...
  -
    apply S_rec with (L:=L \u {{X}} \u dom E);intros.
    +
      rewrite subst_tt_open_tt_var...
      apply subst_tt_wfs...
      get_well_form.
      constructor...
      rewrite_alist (nil ++ [(X0, bind_sub)] ++ E).
      apply WFS_weakening...
      apply H...
      get_well_form...
      apply WFS_type in H3...
    +
      rewrite subst_tt_open_tt_var...
      apply subst_tt_wfs...
      get_well_form.
      constructor...
      rewrite_alist (nil ++ [(X0, bind_sub)] ++ E).
      apply WFS_weakening...
      apply H0...
      get_well_form...
      apply WFS_type in H8...
    +
      rewrite <-rcd_transform...
      rewrite <- rcd_transform...
      apply H2...
      rewrite_alist (nil ++ (X0 ~ bind_sub) ++ E).
      apply Sub_weakening...
      simpl.
      constructor...
      get_well_form...
      rewrite_alist (nil ++ (X0 ~ bind_sub) ++ E).
      apply Sub_weakening...
      simpl.
      constructor...
      get_well_form...
      get_well_form...
      apply WFS_type in H8...
      specialize_x_and_L X0 L.
      apply WFS_type in H0...
      get_well_form...
      apply WFS_type in H3...
      specialize_x_and_L X0 L.
      apply WFS_type in H...
Qed.

Lemma wf_env_weakening: forall E1 E2 X,
    wf_env (E1++E2) ->
    X \notin dom (E1++E2) ->
    wf_env (E1 ++ (X~bind_sub) ++ E2).
Proof with auto.
  intros E1.
  induction E1;intros...
  constructor...
  destruct a.
  rewrite_alist ((a, b) :: E1 ++ E2) in H.
  rewrite_alist ((a, b) :: E1 ++ [(X, bind_sub)] ++ E2).
  dependent destruction H.
  constructor...
Qed.


Lemma subst_tt_rcd: forall  Y X A B,
    (typ_rcd X (subst_tt Y A B)) = subst_tt Y A (typ_rcd X B).
Proof with auto.
  intros...
Qed.  
Lemma subst_tt_wfs3: forall  B E1 E2 X A,
    WFS (E1 ++ (X ~ bind_sub) ++ E2) B ->
    WFS (E1 ++ E2 ) A ->
    X \notin fv_tt A ->
    WFS (E1 ++ E2) (subst_tt X A B).
Proof with auto.
  intros.
  dependent induction H;intros;simpl in *...
  -
    destruct (X0==X)...
    analyze_binds H...
  -
    assert (type A).
    apply WFS_type in H3...
    apply WFS_rec with (L:=L \u {{X}} \u fv_tt A );intros.
    rewrite  subst_tt_open_tt_var...
    rewrite  subst_tt_rcd.
    rewrite  <- subst_tt_open_tt...
    rewrite_alist (([(X0, bind_sub)] ++ E1) ++ E2).
    apply H0...
    rewrite_alist (nil ++ [(X0, bind_sub)] ++ (E1 ++ E2)).
    apply WFS_weakening...
    rewrite  subst_tt_open_tt_var...
    rewrite_alist (([(X0, bind_sub)] ++ E1) ++ E2).
    apply H2...
    rewrite_alist (nil ++ [(X0, bind_sub)] ++ (E1 ++ E2)).
    apply WFS_weakening...
Qed.

Lemma mu_transform_1: forall C D (Y X:atom) A m,
    type (typ_mu (choose m C D)) ->
    X <> Y ->
    (subst_tt X (typ_mu (choose m C D)) (open_tt A (typ_rcd Y (open_tt A Y)))) =
 (open_tt (subst_tt X (typ_mu (choose m C D)) A)
       (typ_rcd Y (open_tt (subst_tt X (typ_mu (choose m C D)) A) Y))).
Proof with auto.
  intros.
  rewrite subst_tt_open_tt...
  f_equal.
  simpl...
  f_equal.
  rewrite subst_tt_open_tt_var...
Qed.

Lemma mu_transform_2: forall (X Y:atom) C D A m,
    type (typ_rcd X (choose m (open_tt C X) (open_tt D X))) ->
     X <> Y ->
    open_tt (subst_tt X (typ_rcd X (choose m (open_tt C X) (open_tt D X))) A)
    (typ_rcd Y (open_tt (subst_tt X (typ_rcd X (choose m (open_tt C X) (open_tt D X))) A) Y)) =
  subst_tt X (typ_rcd X (choose m (open_tt C X) (open_tt D X)))
    (open_tt A (typ_rcd Y (open_tt A Y))).
Proof with auto.
  intros.
  rewrite subst_tt_open_tt...
  f_equal...
  simpl...
  f_equal...
  rewrite subst_tt_open_tt_var...
Qed.

Lemma sub_generalize_intensive : forall E1 E2 A B C D X m,
    Sub (E1 ++ X ~ bind_sub ++ E2) A B ->
    X \notin fv_tt C \u fv_tt D \u fl_tt A \u fl_tt B \u dom (E1++E2)->
    Sub (E1 ++ X ~ bind_sub ++ E2) (subst_tt X (typ_rcd X (choose m (open_tt C X) (open_tt D X))) A)
    (subst_tt X (typ_rcd X (choose m (open_tt D X) (open_tt C X))) B) ->
    Sub (E1 ++ E2) (typ_mu C) (typ_mu D) ->
    wf_env (E1++E2) ->
    Sub (E1 ++ E2) (subst_tt X (typ_mu (choose m C D)) A) (subst_tt X (typ_mu (choose m D C)) B).
Proof with auto.
  intros.
  generalize dependent m.
  dependent induction H;intros;simpl...
  -
    destruct (X0==X);subst...
    +
      assert (WFS (E1 ++ E2) (typ_mu C)) by (get_well_form;auto).
      assert (WFS (E1 ++ E2) (typ_mu D)) by (get_well_form;auto).
      destruct m...
      simpl in *...
      destruct (X==X)...
      dependent destruction H2.
      pick fresh Y.
      specialize_x_and_L Y L.
      rewrite_alist (nil ++  [(Y, bind_sub)] ++ E1 ++ E2) in H4...
      apply Sub_permutation in H4...
      apply Sub_twice_to_one in H4...
      dependent destruction H6.
      dependent destruction H7.
      dependent destruction H9.
      apply S_rec with (L:=fv_tt D \u fv_tt C \u fl_tt C \u fl_tt D \u {{X}} \u {{Y}} \u L1 \u L0 \u dom (E1++E2));intros...
      rewrite subst_tt_intro with (X:=X0)...
      remember (subst_tt X0 (typ_rcd X0 (open_tt D X0)) (open_tt D X0)).
      rewrite subst_tt_intro with (X:=X0)...
      subst.
      apply subst_tt_equiv...
      *
        rewrite subst_tt_intro with (X:=X)...
        remember (subst_tt X X0 (open_tt D X)).
        rewrite subst_tt_intro with (X:=X)...
        subst.
        rewrite_alist (nil ++ [(X0, bind_sub)] ++ E1 ++ E2).
        apply Sub_replacing...
        apply Sub_permutation...
        constructor...
        constructor...        
      *
        rewrite subst_tt_intro with (X:=X)...
        remember (subst_tt X X0 (open_tt D X)).
        rewrite subst_tt_intro with (X:=X)...
        subst.
        rewrite_alist (nil ++ [(X0, bind_sub)] ++ E1 ++ E2).
        apply Sub_replacing...
        apply Sub_permutation...
        constructor...
        constructor...
      *
        rewrite subst_tt_intro with (X:=Y)...
        remember (subst_tt Y X0 (open_tt C Y)).
        rewrite subst_tt_intro with (X:=Y)...
        subst.
        rewrite_alist (nil ++ [(X0, bind_sub)] ++ E1 ++ E2).
        apply Sub_replacing...
        apply Sub_permutation...
        constructor...
        constructor...     
      *
        rewrite_alist (nil ++ E1 ++ [(Y, bind_sub)] ++ E2).
        apply WFS_permutation...
      *
        rewrite_alist (nil ++ E1 ++ [(Y, bind_sub)] ++ E2).
        apply WFS_permutation...
      *
        apply wf_env_weakening...
      *
        destruct n...
    +
      constructor...
      dependent destruction H0...
      analyze_binds H0...
  -
    constructor...
    apply subst_tt_wfs3...
    destruct m;simpl;get_well_form...
    destruct m;simpl...
  -
    dependent destruction H4.
    simpl in *.
    constructor...
    rewrite choose_flip.
    remember (typ_mu (choose (flip m) C D)).
    rewrite choose_flip.
    subst.
    apply IHSub1...
    rewrite <- choose_flip.
    rewrite <- choose_flip...
  -
    dependent destruction H6.
    assert (type (typ_mu C)) by (get_well_form;apply WFS_type with (E:=(E1++E2));auto).
    assert (type (typ_mu D)) by (get_well_form;apply WFS_type with (E:=(E1++E2));auto).
    dependent destruction H9.
    dependent destruction H10.
    apply S_rec with (L:=L \u L0  \u {{X}} \u L1 \u L2 \u fv_tt C \u fv_tt D  \u dom E1 \u dom E2);intros...
    +
      rewrite subst_tt_open_tt_var...
      rewrite_alist (nil ++ [(X0, bind_sub)] ++ (E1 ++ E2)).
      apply subst_tt_wfs3...
      apply WFS_permutation...
      rewrite_alist ([(X0, bind_sub)] ++ [(X, bind_sub)] ++ E1 ++ E2).
      apply WFS_permutation...
      apply WFS_weakening...
      destruct m;simpl;get_well_form...
      simpl;destruct m...
      destruct m;get_well_form;apply WFS_type with (E:=(E1++E2))...
    +
      rewrite subst_tt_open_tt_var...
      rewrite_alist (nil ++ [(X0, bind_sub)] ++ (E1 ++ E2)).
      apply subst_tt_wfs3...
      apply WFS_permutation...
      rewrite_alist ([(X0, bind_sub)] ++ [(X, bind_sub)] ++ E1 ++ E2).
      apply WFS_permutation...
      apply WFS_weakening...
      destruct m;simpl;get_well_form...
      simpl;destruct m...
      destruct m;get_well_form;apply WFS_type with (E:=(E1++E2))...
    +
      rewrite <- mu_transform_1...
      rewrite <- mu_transform_1...
      rename X0 into Y.
      rewrite_alist (([(Y, bind_sub)] ++ E1) ++ E2).
      apply H2...
      *
        apply notin_union.
        split...
        apply notin_union.
        split...
        apply notin_union.
        split.
        apply notin_fl_tt_open...
        simpl.
        apply notin_union.
        split...
        apply notin_fl_tt_open...
        apply notin_union.
        split...
        apply notin_fl_tt_open...
        simpl.
        apply notin_union.
        split...
        apply notin_fl_tt_open...
      *
        rewrite_alist (nil ++ (Y~ bind_sub) ++ E1 ++ E2).
        apply Sub_weakening...
        constructor...
      *
        constructor...
      *
        rewrite <- mu_transform_2...
        rewrite <- mu_transform_2...
        apply H8...
        destruct m;simpl;constructor...
        rewrite subst_tt_intro with (X:=Y)...
        apply subst_tt_type...
        rewrite subst_tt_intro with (X:=Y)...
        apply subst_tt_type...
        destruct m;simpl;constructor...
        rewrite subst_tt_intro with (X:=Y)...
        apply subst_tt_type...
        rewrite subst_tt_intro with (X:=Y)...
        apply subst_tt_type...
      *
        destruct m;get_well_form;apply WFS_type with (E:=E1++E2)...
      *
        destruct m;get_well_form;apply WFS_type with (E:=E1++E2)...
  -
    dependent destruction H1.
    constructor...
    simpl in *.
    apply IHSub...
Qed.



Lemma unfolding_lemma: forall E A B,
    Sub E (typ_mu A) (typ_mu B) ->
    Sub E (open_tt A (typ_mu A)) (open_tt B (typ_mu B)).
Proof with auto.
  intros.
  assert (Hq:=H).
  dependent destruction H.
  pick fresh X.
  specialize_x_and_L X L.
  assert (Ht:=H1).
  rewrite_alist (nil ++ X~bind_sub ++E) in Ht.
  apply Sub_twice_to_one in Ht...
  apply sub_generalize_intensive with (C:=A) (D:=B) (m:=Pos) in Ht...
  -
    simpl in *...
    rewrite <- subst_tt_intro in Ht...
    rewrite <- subst_tt_intro in Ht...
  -
    apply notin_union.
    split...
    apply notin_union.
    split...
    apply notin_union.
    split.
    apply notin_fl_tt_open...
    apply notin_union.
    split...
    apply notin_fl_tt_open...
  -
    simpl in *...
    rewrite <- subst_tt_intro...
    rewrite <- subst_tt_intro...
  -
    get_well_form...
Qed.

End Nominal.




(* ========================================================== *)
(* ========================================================== *)
(* ========================================================== *)
(* ========================================================== *)
(* ========================================================== *)
(* ========================================================== *)
(* ========================================================== *)
(* ========================================================== *)
(* ========================================================== *)
(* ========================================================== *)
(* ========================================================== *)


Fixpoint upcast (A:typ) : Nominal.typ :=
  match A with
  | typ_nat => Nominal.typ_nat
  | typ_top => Nominal.typ_top
  | typ_fvar x => Nominal.typ_fvar x
  | typ_bvar b => Nominal.typ_bvar b
  | typ_arrow s t => Nominal.typ_arrow (upcast s) (upcast t)
  | typ_mu s => Nominal.typ_mu (upcast s)
  end.

Fixpoint upcast_env (E:env) : Nominal.env :=
  match E with
  | nil => nil
  | (x,bind_sub)::E' => (x,Nominal.bind_sub)::(upcast_env E')
  | (x,bind_typ _)::E' => (x,Nominal.bind_sub)::(upcast_env E')
  end.


Lemma notin_dom_upcast: forall E a,
     a `notin` dom E ->
     a `notin` dom (upcast_env E).
Proof with auto.
  induction E;intros...
  destruct a.
  simpl in *.
  destruct b...
Qed.

Lemma In_upcast:forall E X,
  In (X, bind_sub) E ->
     In (X, Nominal.bind_sub) (upcast_env E).
Proof with auto.
  induction E;intros...
  destruct a...
  simpl in *...
  destruct H...
  inversion H.
  apply in_eq...
  destruct b...
  apply in_cons...
  apply in_cons...
Qed.  


Lemma upcast_open : forall A B,
    upcast (open_tt A B) = Nominal.open_tt (upcast A) (upcast B).
Proof with auto.
  intros.
  unfold open_tt.
  unfold Nominal.open_tt.
  generalize 0.
  generalize dependent B.
  induction A;intros;simpl;try solve [f_equal;auto]...
  -
    destruct (n0==n);simpl...
Qed.

Lemma upcast_open_var : forall A (X:atom),
    upcast (open_tt A X) = Nominal.open_tt (upcast A) (Nominal.typ_fvar X).
Proof with auto.
  intros.
  rewrite upcast_open...
Qed.

Lemma WF_upcast : forall E A,
    WF E A -> Nominal.WF (upcast_env E) (upcast A).
Proof with auto.
  intros.
  induction H;simpl in *...
  -
    constructor...
    unfold binds in *.
    apply In_upcast...
  -
    apply Nominal.WF_rec with (L:=L \u Nominal.fv_tt (upcast A));intros...
    specialize_x_and_L X L.
    rewrite upcast_open in H0...
Qed.

Lemma wf_env_upcast : forall E,
    wf_env E -> Nominal.wf_env (upcast_env E).
Proof with auto using notin_dom_upcast.
  intros.
  induction E;simpl...
  destruct a.
  dependent destruction H.
  constructor...
  constructor...
Qed.  

Lemma double_unfolding_upcast : forall E A B,
    sub E A B -> Nominal.sub (upcast_env E) (upcast A) (upcast B).
Proof with auto using wf_env_upcast, WF_upcast.
  intros.
  induction H;simpl...
  -
    constructor...
    constructor...
    unfold binds in *.
    apply In_upcast...
  -
    apply Nominal.Sa_rec with (L:=L \u Nominal.fv_tt (upcast A1) \u Nominal.fv_tt (upcast A2));intros...
    +
      rewrite <- upcast_open_var...
      rewrite <- upcast_open_var...
      apply H0...
    +
      rewrite <- upcast_open_var...
      rewrite <- upcast_open_var...
      rewrite <- upcast_open...
      rewrite <- upcast_open...
      apply H2...
Qed.      
      
Lemma double_to_nominal : forall E A B,
    sub E A B -> Nominal.Sub (upcast_env E) (upcast A) (upcast B).
Proof with auto.
  intros.
  apply double_unfolding_upcast in H.
  apply Nominal.sub_to_Sub...
Qed.



Fixpoint erase (A:Nominal.typ) : typ :=
  match A with
  | Nominal.typ_nat => typ_nat
  | Nominal.typ_top => typ_top
  | Nominal.typ_fvar x => typ_fvar x
  | Nominal.typ_bvar b => typ_bvar b
  | Nominal.typ_arrow s t => typ_arrow (erase s) (erase t)
  | Nominal.typ_mu s => typ_mu (erase s)
  | Nominal.typ_rcd l t => erase t
  end.

Fixpoint erase_env (E:Nominal.env) : env :=
  match E with
  | nil => nil
  | (x,Nominal.bind_sub)::E' => (x,bind_sub)::(erase_env E')
  end.


Lemma notin_dom_downcast: forall E a,
     a `notin` dom E ->
     a `notin` dom (erase_env E).
Proof with auto.
  induction E;intros...
  destruct a.
  simpl in *.
  destruct b...
Qed.

Lemma In_downcast:forall E X,
  In (X, Nominal.bind_sub) E ->
     In (X, bind_sub) (erase_env E).
Proof with auto.
  induction E;intros...
  destruct a...
  simpl in *...
  destruct H...
  inversion H.
  apply in_eq...
  destruct b...
  apply in_cons...
Qed.  


Lemma downcast_open : forall A B,
    erase (Nominal.open_tt A B) = open_tt (erase A) (erase B).
Proof with auto.
  intros.
  unfold open_tt.
  unfold Nominal.open_tt.
  generalize 0.
  generalize dependent B.
  induction A;intros;simpl;try solve [f_equal;auto]...
  -
    destruct (n0==n);simpl...
Qed.

Lemma downcast_open_var : forall A (X:atom),
    erase (Nominal.open_tt A (Nominal.typ_fvar X)) = open_tt (erase A)  X.
Proof with auto.
  intros.
  rewrite downcast_open...
Qed.

Lemma WF_downcast : forall E A,
    Nominal.WF E A -> WF (erase_env E) (erase A).
Proof with auto.
  intros.
  induction H;simpl in *...
  -
    constructor...
    unfold binds in *.
    apply In_downcast...
  -
    apply WF_rec with (L:=L \u fv_tt (erase A));intros...
    specialize_x_and_L X L.
    rewrite downcast_open in H0...
    specialize_x_and_L X L.
    rewrite downcast_open in H0...
    rewrite subst_tt_intro with (X:=X)...
    apply subst_tt_wf...
Qed.

Lemma wf_env_downcast : forall E,
    Nominal.wf_env E -> wf_env (erase_env E).
Proof with auto using notin_dom_downcast.
  intros.
  induction E;simpl...
  destruct a.
  dependent destruction H.
  constructor...
Qed.  


Lemma double_unfolding_downcast : forall E A B,
    Nominal.sub E A B -> sub (erase_env E) (erase A) (erase B).
Proof with auto using wf_env_downcast, WF_downcast.
  intros.
  induction H;simpl...
  -
    constructor...
    dependent destruction H0.
    unfold binds in *.
    apply In_downcast...
  -
    apply sa_rec with (L:=L \u fv_tt (erase A1) \u fv_tt (erase A2));intros...
    +
      rewrite <- downcast_open_var...
      rewrite <- downcast_open_var...
      apply H0...
    +
      rewrite <- downcast_open_var...
      rewrite <- downcast_open_var...
      rewrite <- downcast_open...
      rewrite <- downcast_open...
      apply H2...
Qed.      

Lemma nominal_to_double: forall E A B,
    Nominal.Sub E A B -> sub (erase_env E) (erase A) (erase B).
Proof with auto.
  intros.
  apply double_unfolding_downcast...
  apply Nominal.Sub_to_sub...
Qed.

Corollary nominal_to_finite: forall E A B,
    Nominal.Sub E A B -> Sub (erase_env E) (erase A) (erase B).
Proof with auto.
  intros.
  apply soundness...
  apply nominal_to_double...
Qed.

Corollary finite_to_nominal : forall E A B,
    Sub E A B -> Nominal.Sub (upcast_env E) (upcast A) (upcast B).
Proof with auto.
  intros.
  apply double_to_nominal...
  apply completeness...
Qed.
