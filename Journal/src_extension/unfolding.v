Require Import Metalib.Metatheory.
Require Import Program.Equality.
Require Export subtyping.


Lemma chooseS_flip : forall m X A B C,
    chooseS m X A B C = chooseS (flip m) X B A C.
Proof with auto.
  intros.
  destruct m...
Qed.

Lemma subst_tt_wf2: forall E A B X,
    WF E A  ->
    WF E B ->
    WF E (subst_tt X A B).
Proof with auto.  
    intros.
    dependent induction H0;simpl in *...
    +
      destruct (X0==X)...
    +
      assert (type A).
      get_type...
      apply WF_rec with (L:=L \u {{X}} \u fv_tt A);intros...
      rewrite subst_tt_open_tt_var...
      apply H1...
      rewrite_alist (nil ++ (X0 ~ bind_sub) ++ E).
      apply wf_weakening...
      rewrite subst_tt_open_tt_var...
      rewrite <- subst_tt_open_tt...
      apply H3...
      rewrite_alist (empty ++ [(X0, bind_sub)] ++ E).
      apply wf_weakening...
    +
      constructor...
      apply subst_tt_rt_type with (E:=E)...
      eapply subst_tt_collect...
      eauto.
Qed.

Lemma Sub_weakening: forall E E1 E2 A B,
    Sub (E1++E2) A B ->
    wf_env (E1 ++ E ++ E2) ->
    Sub (E1++E++E2) A B.
Proof with auto.
  intros.
  generalize dependent E.
  dependent induction H;intros;try solve [constructor;auto;apply wf_weakening;auto]...
  -
    apply S_rec with (L:=L \u dom (E1 ++ E ++ E2))...
    intros.
    rewrite_alist (([(X, bind_sub)] ++ E1) ++ E ++ E2).
    apply H0...
    rewrite_alist ([(X, bind_sub)] ++ E1 ++ E ++ E2)...
    intros.
    rewrite_alist (([(X, bind_sub)] ++ E1) ++ E ++ E2)...
    apply H2...
    rewrite_alist ([(X, bind_sub)] ++ E1 ++ E ++ E2)...
  -
    apply S_rcd ...
    apply wf_weakening...
    apply wf_weakening...
    intros.
    apply H6 with (i:=i)...
Qed.

Lemma label_choose_reserve : forall X A B E,
    WF E B ->
    rt_type B ->
    collectLabel B [=] collectLabel (subst_tt X A B).
Proof with auto.
  intros.
  induction B;simpl;try solve [apply AtomSetProperties.equal_refl]...
  inversion H0.
  dependent destruction H.
  apply KeySetProperties.union_equal_2...
Qed.

Definition equiv E A B := Sub E A B /\ Sub E B A.

Lemma label_equiv: forall E C D,
    equiv E C D ->
    collectLabel C [=] collectLabel D.
Proof with auto.
  intros.
  unfold equiv in *.
  destruct H.
  induction H;simpl in *;try solve [apply AtomSetProperties.equal_refl]...
  -
    dependent destruction H0...
    simpl.
    apply AtomSetProperties.equal_refl.
    inversion H2.
  -
    dependent induction H0;simpl in *;try solve [apply AtomSetProperties.equal_refl]...
    +
      inversion H1.
    +
      apply AtomSetProperties.subset_antisym...
Qed.

Lemma union_split: forall A B C,
    union A B [<=] C -> A [<=] C /\ B [<=] C.
Proof with auto.
  intros.
  unfold "[<=]" in *.
  split;intros.
  apply H.
  apply D.F.union_iff...
  apply H.
  apply D.F.union_iff...
Qed.
  

  

Lemma label_equiv_reserve : forall X E A B C D ,
    rt_type A -> rt_type B ->
    collectLabel A [<=] collectLabel B ->
    collectLabel C [=] collectLabel D ->
    WF E A -> WF E B ->
    collectLabel (subst_tt X D A) [<=] collectLabel (subst_tt X C B).
Proof with auto.
  intros.
  induction A; try solve [inversion H].
  -
    induction B; try solve [inversion H0].
    simpl...
    simpl...
    apply KeySetProperties.subset_empty...
  -
    induction B; try solve [inversion H0].
    +
      simpl in *.
      apply union_empty in H1.
      destruct H1.
    +
      simpl in *...
      apply union_split in H1.
      destruct H1.
      apply AtomSetProperties.union_subset_3...
      *
        dependent destruction H4.
        rewrite <- label_choose_reserve with (E:=E)...
      *
        dependent destruction H3.
        apply IHA2...
Qed.

        
Lemma Tlookup_subst: forall E A i X C T,
    WF E A ->
    rt_type A ->
    Tlookup i (subst_tt X C A) = Some T ->
    exists S,
      Tlookup i (subst_tt X C A) = Some (subst_tt X C S) /\ (subst_tt X C S) = T
/\ Tlookup i A = Some S.
Proof with auto.
  intros.
  induction H;try solve [inversion H0]...
  -
    simpl in H1.
    inversion H1.
  -
    simpl in *.
    destruct (i0==i)...
    subst.
    inversion H1...
    exists T1...
Qed.


    
    
    

Lemma subst_tt_equiv: forall E A B,
    Sub E A B -> forall C D X,
      equiv E C D ->
    Sub E (subst_tt X C A) (subst_tt X D B).
Proof with auto.
  intros E A B H.
  induction H;intros;unfold equiv in *;destructs_hypos;simpl in *;try solve [constructor]...
  -
    destruct (X==X0)...
  -
    constructor...
    get_well_form.
    apply subst_tt_wf2...
    
  -
    assert (wf_env E).
    {
      pick fresh Y.
      specialize_x_and_L Y L.
      get_well_form...
    }    
    assert (type C). get_type...
    assert (type D). get_type...
    apply S_rec with (L:=L \u {{X}} \u dom E \u fv_tt C \u fv_tt D);intros.
    rewrite subst_tt_open_tt_var...
    rewrite subst_tt_open_tt_var...
    apply H0...
    split.
    rewrite_alist (nil ++ (X0 ~ bind_sub) ++ E).
    apply Sub_weakening...
    constructor...
    rewrite_alist (nil ++ (X0 ~ bind_sub) ++ E).
    apply Sub_weakening...
    constructor...
    rewrite  subst_tt_open_tt_var ...
    rewrite  subst_tt_open_tt_var ...
    rewrite <- subst_tt_open_tt...
    rewrite <- subst_tt_open_tt...
    apply H2...
    split.
    rewrite_alist (nil ++ (X0 ~ bind_sub) ++ E).
    apply Sub_weakening...
    constructor...
    rewrite_alist (nil ++ (X0 ~ bind_sub) ++ E).
    apply Sub_weakening...
    constructor...
  -
    assert (WF E C). get_well_form...
    assert (WF E D). get_well_form...
    apply S_rcd...
    apply subst_tt_rt_type with (E:=E)...    
    apply subst_tt_rt_type with (E:=E)...
    assert (collectLabel C [=] collectLabel D).
    {
      apply label_equiv with (E:=E)...
      unfold equiv...
    }
    apply label_equiv_reserve with (E:=E)...
    apply subst_tt_wf2...
    apply subst_tt_wf2...
    intros.
    apply Tlookup_subst with (E:=E) in H11...
    apply Tlookup_subst with (E:=E) in H12...
    destruct H11.
    destruct H12.
    destructs_hypos.
    rewrite <- H15.
    rewrite <- H13...
    apply H6 with (i:=i)...
Qed.    


Lemma  subst_tt_rt_type_var : forall E  B X (Y:atom),
    rt_type  B ->
    WF E B ->
    rt_type  (subst_tt X Y B).
Proof with auto.
  intros.
  induction H0;try solve [inversion H]...
  dependent destruction H...
  simpl...
Qed.


Lemma wf_replacing: forall E1 E2 T X Y,
    WF (E1++ X ~ bind_sub ++E2) T ->
    X <> Y ->
    WF (E1++ Y ~ bind_sub ++E2) (subst_tt X Y T).
Proof with auto.
  intros.
  generalize dependent Y.
  dependent induction H;intros;simpl in *...
  -
    destruct (X0==X)...
    constructor.
    analyze_binds H.
  -
    apply WF_rec with (L:=L \u {{X}}).
    intros.
    rewrite  subst_tt_open_tt_var...
    rewrite_alist (([(X0, bind_sub)] ++ E1) ++ Y ~ bind_sub ++ E2).
    apply H0...
    intros.
    rewrite  subst_tt_open_tt_var...
    rewrite <-  subst_tt_open_tt...
    rewrite_alist (([(X0, bind_sub)] ++ E1) ++ Y ~ bind_sub ++ E2).
    apply H2...
  -
    constructor...
    apply subst_tt_rt_type_var with (E:=(E1 ++ (X, bind_sub) :: E2))...
    apply subst_tt_collect with (E:=(E1 ++ (X, bind_sub) :: E2))...    
Qed.

Lemma Sub_replacing: forall E1 E2 A B X Y,
    Sub (E1++ X ~ bind_sub ++E2) A B ->
    X <> Y ->
    wf_env (E1 ++ Y ~ bind_sub ++ E2) ->
    Sub (E1++ Y ~ bind_sub ++E2) (subst_tt X Y A) (subst_tt X Y B).
Proof with auto.
  intros.
  generalize dependent Y.
  dependent induction H;intros;simpl in *;try solve [rewrite_alist (E1 ++ [(Y, bind_sub)] ++ E2);constructor;auto]...
  -
    destruct (X0==X)...
    analyze_binds H0.
  -
    constructor...
    rewrite_alist (E1 ++ [(Y, bind_sub)] ++ E2).
    apply wf_replacing...
  -
    apply S_rec with (L:=L  \u {{X}} \u dom (E1 ++ [(Y, bind_sub)] ++ E2) )...
    +
      intros.
      rewrite  subst_tt_open_tt_var...
      rewrite  subst_tt_open_tt_var...
      rewrite_alist (([(X0, bind_sub)] ++ E1) ++ Y ~ bind_sub ++ E2).
      apply H0...
      rewrite_alist ([(X0, bind_sub)] ++ E1 ++ [(Y, bind_sub)] ++ E2).
      constructor...
    +
      intros.
      rewrite  subst_tt_open_tt_var...
      rewrite  subst_tt_open_tt_var...
      rewrite <-  subst_tt_open_tt...
      rewrite <-  subst_tt_open_tt...
      rewrite_alist (([(X0, bind_sub)] ++ E1) ++ Y ~ bind_sub ++ E2).
      apply H2...
      rewrite_alist ([(X0, bind_sub)] ++ E1 ++ [(Y, bind_sub)] ++ E2).
      constructor...
  -
    apply S_rcd...
    apply subst_tt_rt_type_var with (E:=(E1 ++ (X, bind_sub) :: E2))...
    apply subst_tt_rt_type_var with (E:=(E1 ++ (X, bind_sub) :: E2))...
    apply label_equiv_reserve with (E:=(E1 ++ (X, bind_sub) :: E2))...
    apply AtomSetProperties.equal_refl.
    apply wf_replacing...
    apply wf_replacing...
    intros.
    apply Tlookup_subst with (E:=(E1 ++ (X, bind_sub) :: E2)) in H9...
    apply Tlookup_subst with (E:=(E1 ++ (X, bind_sub) :: E2)) in H10...
    destruct H9.
    destruct H10.
    destructs_hypos.
    rewrite <- H13.
    rewrite <- H11.
    apply H6 with (i:=i)...
Qed.

Lemma WF_permutation: forall E1 E2 E3 E4 A ,
    WF (E1 ++ E2 ++ E3 ++ E4) A  ->
    WF (E1 ++ E3 ++ E2 ++ E4) A .
Proof with auto.
  intros.
  dependent induction H...
  -
    constructor...
    analyze_binds H...
  -
    apply WF_rec with (L:=L);intros.
    rewrite_alist (([(X, bind_sub)] ++ E1) ++ E3 ++ E2 ++ E4).
    apply H0...
    rewrite_alist (([(X, bind_sub)] ++ E1) ++ E3 ++ E2 ++ E4).
    apply H2...
Qed.    
    
Lemma Sub_permutation: forall E1 E2 E3 E4 A B,
    Sub (E1 ++ E2 ++ E3 ++ E4) A B ->
    wf_env (E1 ++ E3 ++ E2 ++ E4) ->
    Sub (E1 ++ E3 ++ E2 ++ E4) A B.
Proof with auto.
  intros.
  dependent induction H...
  -
    constructor...
    analyze_binds H0...
  -
    constructor...
    apply WF_permutation...
  -
    apply S_rec with (L:=L \u dom (E1++E3++E2++E4));intros.
    rewrite_alist (([(X, bind_sub)] ++ E1) ++ E3 ++ E2 ++ E4).
    apply H0...
    rewrite_alist ([(X, bind_sub)] ++ E1 ++ E3 ++ E2 ++ E4)...
    rewrite_alist (([(X, bind_sub)] ++ E1) ++ E3 ++ E2 ++ E4).
    apply H2...
    rewrite_alist ([(X, bind_sub)] ++ E1 ++ E3 ++ E2 ++ E4)...
  -
    apply S_rcd...
    apply WF_permutation...
    apply WF_permutation...
    intros.
    apply H6 with (i:=i)...
Qed.

Lemma Tlookup_subst_rev: forall i X B A T E,
    rt_type A -> WF E A ->
    Tlookup i A = Some T ->
    Tlookup i (subst_tt X B A) = Some (subst_tt X B T).
Proof with auto.
  intros.
  induction H0;try solve [inversion H]...
  simpl in *.
  inversion H1.
  simpl in *.
  destruct (i0==i)...
  inversion H1...
Qed.  

(*

The conventional 3rd premise should be written as 
Sub (E1 ++ (X~bind_sub) ++ E2) (chooseS m X (open_tt C X) (open_tt D X) A) (chooseS m X (open_tt D X) (open_tt C X) B)

Here for convenient, the context changes to ((X~bind_sub) ++ E1 ++ E2).
The lemma Sub_permutation guarantee these two forms are equivalent.

*)
Lemma sub_generalize_intensive : forall E1 E2 X A B ,
    Sub (E1 ++ (X~bind_sub) ++ E2) A B ->
    forall C D  m,
      X \notin fv_tt C \u fv_tt D -> 
      Sub ((X~bind_sub) ++ E1 ++ E2) (chooseS m X (open_tt C X) (open_tt D X) A) (chooseS m X (open_tt D X) (open_tt C X) B) ->
      Sub (E1 ++ E2) (typ_mu C) (typ_mu D) ->                  
    Sub (E1 ++ E2) (chooseS m X (typ_mu C) (typ_mu D) A) (chooseS m X (typ_mu D) (typ_mu C) B).
Proof with auto.
  intros E1 E2 X A B H.
  dependent induction H; intros; try solve [simpl in *;destruct m;get_well_form;eauto]...
  -
    destruct m; unfold chooseS;simpl in *;destruct (X0==X)...
    subst.
    assert (ht:=H3).
    dependent destruction H3.
    apply S_rec with (L:=L \u {{X}} \u fv_tt C \u fv_tt D \u dom E1 \u dom E2);intros.
    +
      rewrite subst_tt_intro with (X:=X)...
      remember (subst_tt X X0 (open_tt D X)).
      rewrite subst_tt_intro with (X:=X)...
      subst.
      add_nil.
      apply Sub_replacing...
      constructor...
      get_well_form...
    +
      rewrite subst_tt_intro with (X:=X0)...
      remember (subst_tt X0 (open_tt D X0) (open_tt D X0)).
      rewrite subst_tt_intro with (X:=X0)...
      subst.
      assert (Sub ((X0, bind_sub) :: E1 ++ E2) (open_tt D X0) (open_tt C X0)).
      {
        rewrite subst_tt_intro with (X:=X)...
        remember (subst_tt X X0 (open_tt D X)).
        rewrite subst_tt_intro with (X:=X)...
        subst.
        rewrite_alist (nil ++ (X0 ~ bind_sub) ++ E1 ++ E2).
        apply Sub_replacing...
        constructor...
        get_well_form...
      }
      apply subst_tt_equiv...
      unfold equiv.
      split...
    +
      inversion H4.
    +
      constructor...
      get_well_form...
      analyze_binds H0...
    +
      constructor...
      get_well_form...
      analyze_binds H0...
  -
    destruct m;unfold chooseS;simpl in *;constructor...
    get_well_form...
    apply subst_tt_wf...
    get_well_form...
    get_well_form...
    apply subst_tt_wf...
    get_well_form...
  -
    rewrite chooseS_arrow in H2.
    rewrite chooseS_arrow in H2.
    rewrite chooseS_arrow.
    rewrite chooseS_arrow.
    dependent destruction H2...
    constructor...
    rewrite chooseS_flip.
    remember (chooseS (flip m) X (typ_mu C) (typ_mu D) B1).
    rewrite chooseS_flip.
    subst.
    apply IHSub1...
    rewrite <- chooseS_flip.
    rewrite <- chooseS_flip...
    inversion H4.
  -
    rewrite chooseS_mu.
    rewrite chooseS_mu.
    rewrite chooseS_mu in H4.
    rewrite chooseS_mu in H4.
    assert (type (typ_mu C)). get_type...
    assert (type (typ_mu D)). get_type...
    dependent destruction H4.
    assert (type (open_tt C X)).
    {
      dependent destruction H7.
      pick fresh Y.
      specialize_x_and_L Y L1.
      get_type...
      rewrite subst_tt_intro with (X:=Y)...
      apply subst_tt_type...      
    }
    assert (type (open_tt D X)).
    {
      dependent destruction H8.
      pick fresh Y.
      specialize_x_and_L Y L1.
      get_type...
      rewrite subst_tt_intro with (X:=Y)...
      apply subst_tt_type...      
    }

    apply S_rec with (L := L \u L0 \u fv_tt A1 \u fv_tt A2 \u fv_tt C \u fv_tt D \u {{X}} \u dom E1 \u dom E2);intros.
    +
      rewrite <- chooseS_open...
      rewrite <- chooseS_open...
      rewrite_alist (([(X0, bind_sub)] ++ E1) ++ E2).
      apply H0...
      rewrite chooseS_open...
      rewrite chooseS_open...
      rewrite_alist (nil ++ [(X, bind_sub)] ++ [(X0, bind_sub)] ++ E1 ++ E2).
      apply Sub_permutation...
      apply H4...
      simpl.
      constructor...
      get_well_form.
      constructor...
      simpl.
      apply notin_add_3...
      specialize_x_and_L X0 L0.
      get_well_form.
      dependent destruction H4.
      dependent destruction H4...
      rewrite_alist (nil ++ [(X0, bind_sub)] ++ E1 ++ E2).
      apply Sub_weakening...
      constructor...
      get_well_form...
    +
      rewrite <- chooseS_open2...
      rewrite <- chooseS_open2...
      rewrite_alist (([(X0, bind_sub)] ++ E1) ++ E2).
      apply H2...
      rewrite chooseS_open2...
      rewrite chooseS_open2...
      rewrite_alist (nil ++ [(X, bind_sub)] ++ [(X0, bind_sub)] ++ E1 ++ E2).
      apply Sub_permutation...
      apply H5...
      simpl.
      constructor...
      get_well_form.
      constructor...
      simpl.
      apply notin_add_3...
      specialize_x_and_L X0 L0.
      get_well_form.
      dependent destruction H4.
      dependent destruction H4...
      rewrite_alist (nil ++ [(X0, bind_sub)] ++ E1 ++ E2).
      apply Sub_weakening...
      constructor...
      get_well_form...
    +
      inversion H6.
      
  -
    assert (WF (E1 ++ E2) (typ_mu C)). get_well_form...
    assert (WF (E1 ++ E2) (typ_mu D)). get_well_form...
    apply S_rcd...
    get_well_form...
    destruct m;apply subst_tt_rt_type with (E:=(E1 ++ [(X, bind_sub)] ++ E2))...
    apply wf_weakening...
    apply wf_weakening...
    destruct m;apply subst_tt_rt_type with (E:=(E1 ++ [(X, bind_sub)] ++ E2))...
    apply wf_weakening...
    apply wf_weakening...
    destruct m;simpl.
    apply  label_equiv_reserve with (E:=(E1 ++ [(X, bind_sub)] ++ E2))...
    simpl.
    apply AtomSetProperties.equal_refl...
    apply  label_equiv_reserve with (E:=(E1 ++ [(X, bind_sub)] ++ E2))...
    simpl.
    apply AtomSetProperties.equal_refl...
    destruct m;apply subst_tt_wf...
    destruct m;apply subst_tt_wf...
    intros.
    destruct m;simpl in *.
    +
      apply Tlookup_subst with (E:=(E1 ++ (X, bind_sub) :: E2)) in H12...
      apply Tlookup_subst with (E:=(E1 ++ (X, bind_sub) :: E2)) in H13...
      destruct H12.
      destruct H13.
      destructs_hypos.
      rewrite <- H16.
      rewrite <- H14.
      assert (E1 ++ (X, bind_sub) :: E2 ~= E1 ++ (X, bind_sub) :: E2) by auto.
      specialize (H6 i _ _ H17 H15 _ _ _ H18 C D Neg).
      simpl in *.
      apply H6...
      assert (rt_type (subst_tt X (open_tt D X) A1)).
      {
        apply subst_tt_rt_type with (E:=(E1 ++ (X, bind_sub) :: E2))...
        dependent destruction H11.
        pick fresh Y.
        rewrite subst_tt_intro with (X:=Y)...
        apply wf_replacing...
        add_nil.
        apply WF_permutation...
        apply H11...
      }
      assert (rt_type (subst_tt X (open_tt C X) A2)).
      {
        apply subst_tt_rt_type with (E:=(E1 ++ (X, bind_sub) :: E2))...
        dependent destruction H10.
        pick fresh Y.
        rewrite subst_tt_intro with (X:=Y)...
        apply wf_replacing...
        add_nil.
        apply WF_permutation...
        apply H10...
      }
      apply rcd_inversion with (i:=i) (t1:=(subst_tt X (open_tt D X) x)) (t2:=(subst_tt X (open_tt C X) x0)) in H8...
      apply Tlookup_subst_rev with (E:=(E1 ++ (X, bind_sub) :: E2))...
      apply Tlookup_subst_rev with (E:=(E1 ++ (X, bind_sub) :: E2))...
    +
      apply Tlookup_subst with (E:=(E1 ++ (X, bind_sub) :: E2)) in H12...
      apply Tlookup_subst with (E:=(E1 ++ (X, bind_sub) :: E2)) in H13...
      destruct H12.
      destruct H13.
      destructs_hypos.
      rewrite <- H16.
      rewrite <- H14.
      assert (E1 ++ (X, bind_sub) :: E2 ~= E1 ++ (X, bind_sub) :: E2) by auto.
      specialize (H6 i _ _ H17 H15 _ _ _ H18 C D Pos).
      simpl in *.
      apply H6...
      assert (rt_type (subst_tt X (open_tt C X) A1)).
      {
        apply subst_tt_rt_type with (E:=(E1 ++ (X, bind_sub) :: E2))...
        dependent destruction H10.
        pick fresh Y.
        rewrite subst_tt_intro with (X:=Y)...
        apply wf_replacing...
        add_nil.
        apply WF_permutation...
        apply H10...
      }
      assert (rt_type (subst_tt X (open_tt D X) A2)).
      {
        apply subst_tt_rt_type with (E:=(E1 ++ (X, bind_sub) :: E2))...
        dependent destruction H11.
        pick fresh Y.
        rewrite subst_tt_intro with (X:=Y)...
        apply wf_replacing...
        add_nil.
        apply WF_permutation...
        apply H11...
      }
      apply rcd_inversion with (i:=i) (t1:=(subst_tt X (open_tt C X) x)) (t2:=(subst_tt X (open_tt D X) x0)) in H8...
      apply Tlookup_subst_rev with (E:=(E1 ++ (X, bind_sub) :: E2))...
      apply Tlookup_subst_rev with (E:=(E1 ++ (X, bind_sub) :: E2))...
    
Qed.


Lemma unfolding_lemma :
  forall E A B,
    Sub E (typ_mu A) (typ_mu B) ->
    Sub E (open_tt A (typ_mu A)) (open_tt B (typ_mu B)).
Proof with auto.
  intros.
  assert (Ht:=H).
  dependent destruction Ht.
  pick fresh X.
  add_nil.
  rewrite subst_tt_intro with (X:=X)...
  remember (subst_tt X (typ_mu A) (open_tt A X)).
  rewrite subst_tt_intro with (X:=X)...
  subst.
  apply sub_generalize_intensive with (m:=Pos)...
  apply H0...
  simpl...
  rewrite <- subst_tt_intro...
  rewrite <- subst_tt_intro...
  apply H1...
  inversion H1.
Qed.  
